{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack://pushstatetree.source/push-state-tree.min.js","webpack:///webpack/bootstrap 73a3621111e337ada1f6?fbc0","webpack:///./src/pushStateTree.js?c559","webpack:///./~/babel-runtime/core-js/object/define-property.js?5f70","webpack:///./~/core-js/library/fn/object/define-property.js?b7d8","webpack:///./~/core-js/library/modules/$.js?6ce7"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","global","_interopRequireDefault","obj","__esModule","default","isInt","n","isNaN","parseFloat","isFinite","wrapProperty","scope","prop","target","_defineProperty2","get","set","isExternal","url","test","isRelative","uri","resolveRelativePath","path","parts","split","i","length","splice","join","replace","PushStateTree","options","wrappMethodsAndPropertiesToPrototype","prototype","rootElement","apply","arguments","val","USE_PUSH_STATE","elementPrototype","document","createElement","VERSION","hasOwnProperty","HAS_PUSH_STATE","usePushState","Object","defineProperty","beautifyLocation","value","basePath","protoProperty","history","state","cachedUri","location","href","hash","match","isPathValid","replaceState","title","pathname","search","slice","getAttribute","setAttribute","configurable","indexOf","eventStack","leave","change","enter","addEventListener","POPSTATE","eventURI","eventState","rulesDispatcher","oldURI","oldState","holdingDispatch","dispatch","bind","readOnhashchange","onhashchange","avoidHashchangeHandler","removeEventListener","HASHCHANGE","dispatchHashChange","dispatchEvent","HashChangeEvent","_this","isIE","setInterval","preProcessUriBeforeExecuteNativeHistoryMethods","method","scopeMethod","args","Array","_defineProperty","window","trident","navigator","userAgent","origin","protocol","host","Function","oThis","TypeError","aArgs","fToBind","FNOP","fBound","context","concat","Event","CustomEvent","event","params","bubbles","cancelable","detail","undefined","evt","createEvent","initCustomEvent","Element","opera","version","e","proto","createEventObject","constructor","srcElement","addEventListenerFunc","type","handler","__bindedFunctions","fn","__elemetIEid","Math","random","customEventId","element","propHandler","propertyName","documentElement","push","original","binded","attachEvent","bindedFn","HTMLDocument","removeEventListenerFunc","detachEvent","j","name","customEvent","dispatchEventFunc","fireEvent","modernBrowser","builtinSlice","arr","forEach","action","that","String","trim","filter","fun","t","len","res","thisArg","LEAVE","UPDATE","ENTER","CHANGE","MATCH","OLD_MATCH","HTMLElement","eventsQueue","holdDispatch","createRule","rule","ruleRegex","RegExp","toString","slicedPattern","attr","removeAttribute","oldMatch","methodName","parentElement","add","appendChild","remove","queryOrElement","querySelector","removeChild","assign","pushState","navigate","runner","children","childNodes","recursiveDispatcher","ruleElement","PushStateTreeEvent","useURI","useOldURI","parentGroup","routerURI","events","isNewURI","last","shift","lastTitle","lastIndexOf","Error","relativePos","$","it","key","desc","setDesc","$Object","create","getProto","getPrototypeOf","isEnum","propertyIsEnumerable","getDesc","getOwnPropertyDescriptor","setDescs","defineProperties","getKeys","keys","getNames","getOwnPropertyNames","getSymbols","getOwnPropertySymbols","each"],"mappings":";;;;;CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,cAAAD,IAEAD,EAAA,cAAAC,KACCK,KAAA,WACD,MCKgB,UAAUC,GCX1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDqBM,SAASL,EAAQD,EAASM,IAEH,SAASS,GAAS,YAM9C,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GEqPxF,QAASG,GAAMC,GACb,OAAQC,MAAMC,WAAWF,KAAOA,EAAI,IAAM,GAAKG,SAASH,GAG1D,QAASI,GAAaC,EAAOC,EAAMC,IACjC,EAAAC,cAAsBH,EAAOC,GAC3BG,IAAK,WACH,MAAOF,IAETG,IAAK,eAIT,QAASC,GAAWC,GAElB,MAAO,mBAAqBC,KAAKD,GAGnC,QAASE,GAAWC,GAElB,MAAO,UAAWF,KAAKE,GAGzB,QAASC,GAAoBC,GAK3B,IAFA,GAAIC,GAAQD,EAAKE,MAAM,KACnBC,EAAI,EACDA,EAAIF,EAAMG,QAEE,OAAbH,EAAME,IAAeA,EAAI,GAAoB,OAAfF,EAAME,EAAE,KACxCF,EAAMI,OAAOF,EAAI,EAAG,GACpBA,GAAK,GAEPA,GAEF,OAAOF,GACJK,KAAK,KACLC,QAAQ,sBAAuB,KAC/BA,QAAQ,OAAQ,IAMrB,QAASC,GAAcC,GA6DrB,QAASC,GAAqCrB,GAC5C,GAA6C,kBAAlCmB,GAAcG,UAAUtB,GAEjCuB,EAAYvB,GAAQ,WAClB,MAAOmB,GAAcG,UAAUtB,GAAMwB,MAAM/C,KAAMgD,gBAE9C,CACL,GAAiC,mBAAtBF,GAAYvB,GAAuB,QADzC,EAAAE,cAGiBqB,EAAavB,GACjCG,IAAK,WACH,MAAOgB,GAAcG,UAAUtB,IAEjCI,IAAK,SAAUsB,GACbP,EAAcG,UAAUtB,GAAQ0B,MA3EV,GAC9BN,EAAUA,MACVA,EAAQO,GAAkBP,EAAQO,MAAoB,IAGhDlD,eAAgBmD,IACpB,MAAOT,GAAcK,MAAMK,EAASC,cAAc,uBAAwBL,UAG5E,IAAIF,GAAc9C,IAClBA,MAAKsD,QAAU,QAVe,KAazB,GAAI/B,KAAQoB,GACXA,EAAQY,eAAehC,KACzBuB,EAAYvB,GAAQoB,EAAQpB,GAfF,IAsBzBmB,EAAcG,UAAUW,GAEtB,CACL,GAAIC,GAAed,EAAQO,IAC3B,EAAAzB,cAAsBqB,EAAaI,GACjCxB,IAAK,WACH,MAAO+B,IAET9B,IAAK,SAAUsB,GACbQ,EAAeR,KAAQ,SAR3B5B,GAAayB,EAAaI,GAAgB,EAvBdQ,QAqCvBC,eAAeb,EAAa,oBACjCpB,IAAK,WACH,MAAOgB,GAAcG,UAAUe,kBAAoBH,GAErD9B,IAAK,SAAUkC,GACbnB,EAAcG,UAAUe,iBAAmBC,KAAU,KAGzDf,EAAYc,iBAAmBjB,EAAQiB,kBAAoBd,EAAYW,YAEvE,IAAIK,EACJJ,QAAOC,eAAeb,EAAa,YACjCpB,IAAK,WACH,MAAOoC,IAETnC,IAAK,SAAUkC,GACbC,EAAWD,GAAS,GACA,MAAhBC,EAAS,KACXA,EAAW,IAAMA,MAIvBhB,EAAYgB,SAAWnB,EAAQmB,QA3DD,KAkFzB,GAAIC,KAAiBrB,GAAcG,UAClCH,EAAcG,UAAUU,eAAeQ,IACzCnB,EAAqCmB,EAIzC1C,GAAayB,EAAa,SAAUpD,EAAKsE,QAAQ1B,QACjDjB,EAAayB,EAAa,QAASpD,EAAKsE,QAAQC,MAEhD,IAAIC,IACFrC,IAAK,GACLG,IAAK,GAEP0B,QAAOC,eAAeb,EAAa,OACjCpB,IAAK,WACH,GAAIwC,EAAUrC,MAAQnC,EAAKyE,SAASC,KAAM,MAAOF,GAAUlC,GAE3D,IAAIA,EACJ,IAAItC,EAAKyE,SAASE,KAAK/B,QAA2D,MAAjD5C,EAAKyE,SAASC,KAAKD,EAASC,KAAK9B,OAAS,GAAY,CAErFN,EAAMtC,EAAKyE,SAASE,KAAKC,MAAM,iBAAiB,EAEhD,IAAIb,GAAeX,EAAYI,EAC3BJ,GAAYc,kBAAoBd,EAAYyB,aAAed,GAG7DX,EAAY0B,aACV1B,EAAYmB,MACZnB,EAAY2B,MACD,MAAXzC,EAAI,GAAaA,EAAM,IAAMA,OAIjCA,GAAMtC,EAAKyE,SAASO,SAAWhF,EAAKyE,SAASQ,OACzC3E,KAAKuE,cACPvC,EAAMA,EAAI4C,MAAM5E,KAAK8D,SAASxB,QAalC,OAlCeN,GA0BTA,EAAIS,QAAQ,SAAU,IAExBK,EAAY+B,aAAa,SAAW7C,GACtCc,EAAYgC,aAAa,MAAO9C,GAGlCkC,EAAUrC,IAAMnC,EAAKyE,SAASC,KAC9BF,EAAUlC,IAAMA,EACTA,GAET+C,cAAc,IAGhBrB,OAAOC,eAAeb,EAAa,eACjCpB,IAAK,WACH,GAAIM,GAAMtC,EAAKyE,SAASO,SAAWhF,EAAKyE,SAASQ,MACjD,QAAQ3E,KAAK8D,UAA6C,IAAjC9B,EAAMgD,QAAQhF,KAAK8D,aAIhDhB,EAAYmC,YACVC,SACAC,UACAC,SACAd,UAGF5E,EAAK2F,iBAAiBC,EAAU,WAC9B,GAAIC,GAAWzC,EAAYd,IACvBwD,EAAa1C,EAAYmB,KAC7BnB,GAAY2C,kBAEZC,EAASH,EACTI,EAAWH,EAGPI,GACF5F,KAAK6F,YAEPC,KAAKhD,GAEP,IAAIiD,IAAmB,EACnBC,EAAe,WAEjB,IAAID,GAGAL,IAAW5C,EAAYd,IALE,CAO7B,GAAIuD,GAAWzC,EAAYd,IACvBwD,EAAa1C,EAAYmB,KAC7BnB,GAAY2C,kBAEZC,EAASH,EACTI,EAAWH,EAGPI,GACF5F,KAAK6F,aAEPC,KAAKhD,EAEPA,GAAYmD,uBAAyB,WAEnCvG,EAAKwG,oBAAoBC,EAAYH,GACrCD,GAAmB,GAGrBrG,EAAK2F,iBAAiBc,EAAYH,EA9LJ,IAiM1BI,GAAqB,WACvB1G,EAAK2G,cAAc,GAAIC,GAAgBH,IA0BzC,OA5N8B/C,GAsMrBiC,iBAAiB,mBAAoBe,GAtMhB1G,EAwMzB2F,iBAAiB,mBAAoBe,GAxMZ1G,EA0MzB2F,iBAAiB,OAAQ,WFiF3B,GAAIkB,GAAQvG,IEhFboG,KAEII,GACF9G,EAAK+G,YAAY,WACf,MAAIF,GAAKvE,MAAQ0D,MACfU,UAGEL,IACFA,GAAmB,EACnBL,EAASa,EAAKvE,IACdtC,EAAK2F,iBAAiBc,EAAYH,MAEnC,KAELF,KAAKhD,IAEA9C,KAuUT,QAAS0G,GAA+CC,GAEtD,GAAIC,GAAcD,CAClB3G,MAAK2G,GAAU,WAIb,GAAIE,GAAOC,MAAMjE,UAAU+B,MAAMrE,KAAKyC,UAJb,KAOL,cAAhB4D,GAA+C,iBAAhBA,KAE5BhF,EAAWiF,EAAK,IAAK,CAGxB,GAAI9E,EAAW8E,EAAK,IAAK,CAEvB,GAAI/C,GAAW9D,KAAKgC,IAAIsC,MAAM,cAC9BR,GAAWA,EAAWA,EAAS,GAAK,IAAM,GAC1C+C,EAAK,GAAK/C,EAAW+C,EAAK,OAG1BA,GAAK,GAAKA,EAAK,GAAGvC,MAAM,kBAAiB,EAGtCtE,MAAKkD,GASR2D,EAAK,GAAK7G,KAAK8D,SAAW+C,EAAK,GAJ/BA,EAAK,GAAK1C,EAASO,SAAW,IAAMzC,EAAoB4E,EAAK,IA3B1C,MAoCzBnH,GAAKsE,QAAQ4C,GAAa7D,MAAMrD,EAAKsE,QAAS6C,GAGvC7G,MFn3BV,GAAI+G,GAAkB7G,EAAoB,GAEtCuB,EAAmBb,EAAuBmG,GEjE3CrH,EAAyB,mBAAXsH,SAA0BA,QAAUrG,EAClDyC,EAAW1D,EAAK0D,SAChBe,EAAWzE,EAAKyE,SAEhBqC,EAAQ,WACV,GAAIS,GAAUD,OAAOE,UAAUC,UAAUnC,QAAQ,UACjD,OAAOiC,IAAW,MAIpB,WAEOvH,EAAKyE,SAASiD,SACjB1H,EAAKyE,SAASiD,OAAS1H,EAAKyE,SAASkD,SAAW,KAAO3H,EAAKyE,SAASmD,SAIzE,WAEMC,SAAS1E,UAAUiD,OAEvByB,SAAS1E,UAAUiD,KAAO,SAAU0B,GAClC,GAAoB,kBAATxH,MAET,KAAM,IAAIyH,WAAU,uEAGtB,IAAIC,GAAQZ,MAAMjE,UAAU+B,MAAMrE,KAAKyC,UAAW,GAChD2E,EAAU3H,KACV4H,EAAO,aACPC,EAAS,WACP,GAAIC,GAAUN,CAId,OAHIxH,gBAAgB4H,IAAQJ,IAC1BM,EAAU9H,MAEL2H,EAAQ5E,MAAM+E,EAASJ,EAAMK,OAAOjB,MAAMjE,UAAU+B,MAAMrE,KAAKyC,aAM1E,OAHA4E,GAAK/E,UAAY7C,KAAK6C,UACtBgF,EAAOhF,UAAY,GAAI+E,GAEhBC,MAKX,IAAIvB,GAAkB5G,EAAK4G,gBACvB0B,EAAQtI,EAAKsI,OAEjB,WAGE,QAASC,GAAYC,EAAOC,GAC1BA,EAASA,IACPC,SAAS,EACTC,YAAY,EACZC,OAAQC,OAEV,IAAIC,GAAMpF,EAASqF,YAAY,cAE/B,OADAD,GAAIE,gBAAgBR,EAAOC,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAC9DE,EAVT,GAAKG,QAAQ9F,UAAUwC,iBAAvB,CAaA4C,EAAYpF,UAAYmF,EAAMnF,UAEzBnD,EAAKuI,cAAiBzB,IACzB9G,EAAKuI,YAAcA,KAIhB3B,GAAoB5G,EAAKkJ,OAASlJ,EAAKkJ,MAAMC,UAAY,IAASrC,KACrEF,EAAkB5G,EAAKuI,aAGrBzB,IACFwB,EAAQC,EA1BC,KA+BT,GAAI3B,GAAgB,cACpB,MAAMwC,GACNxC,EAAkB2B,EAGpB,IACE,GAAID,GAAM,YACV,MAAOc,GACPd,EAAQC,OAKZ,WACE,IAAIU,QAAQ9F,UAAUwC,kBAAoB5D,aAA1C,CADW,GAIPsH,GAAQ3F,EAAS4F,oBAAoBC,YAAYpG,SAErDa,QAAOC,eAAeoF,EAAO,UAC3BrH,IAAK,WAAa,MAAO1B,MAAKkJ,aAPrB,IAWPC,GAAuB,SAASC,EAAMC,GACnCrJ,KAAKsJ,oBACRtJ,KAAKsJ,qBAGP,IAAIC,GAAKF,CAET,MAAM,KAAOD,IAAQpJ,QAAkB,eAAToJ,EAAuB,CACnDpJ,KAAKwJ,aAAexJ,KAAKwJ,cAAgB,SAAWC,KAAKC,QACzD,IAAIC,GAAgBP,EAAOpJ,KAAKwJ,aAG5BI,EAAU5J,KAEV6J,EAAc,SAAU3B,GAEtBA,EAAM4B,eAAiBH,GACzBJ,EAAGhJ,KAAKqJ,EAASxG,EAAS2G,gBAAgBJ,IAW9C,IAPA3J,KAAKsJ,kBAAkBU,MACrBC,SAAUV,EACVW,OAAQL,IAGVzG,EAAS2G,gBAAgBI,YAAY,mBAAoBN,GAE5C,eAATT,EAAyB,OAG/B,GAAIgB,GAAWb,EAAGzD,KAAK9F,KAEvBA,MAAKsJ,kBAAkBU,MACrBC,SAAUV,EACVW,OAAQE,IAGVpK,KAAKmK,YAAY,KAAOf,EAAMgB,GAjDrBC,cAqDExH,UAAUwC,iBAAmB8D,EAC1CR,QAAQ9F,UAAUwC,iBAAmB8D,EACrCnC,OAAO3B,iBAAmB8D,CAvDf,IA0DPmB,GAA0B,SAASlB,EAAMC,GACtCrJ,KAAKsJ,oBACRtJ,KAAKsJ,qBAGP,IAEIc,GAFAb,EAAKF,CAIT,MAAM,KAAOD,IAAQpJ,QAAkB,eAAToJ,EAAuB,CACnD,IAAK,GAAI/G,GAAI,EAAGA,EAAIrC,KAAKsJ,kBAAkBhH,OAAQD,IAC7CrC,KAAKsJ,kBAAkBjH,GAAG4H,WAAaV,IACzCa,EAAWpK,KAAKsJ,kBAAkBjH,GAAG6H,OACrClK,KAAKsJ,kBAAoBtJ,KAAKsJ,kBAAkB/G,OAAOF,EAAG,GAC1DA,EAAIrC,KAAKsJ,kBAAkBhH,OAQ/B,IAJI8H,GACFhH,EAAS2G,gBAAgBQ,YAAY,mBAAoBH,GAG9C,eAAThB,EAAyB,OAG/B,IAAK,GAAIoB,GAAI,EAAGA,EAAIxK,KAAKsJ,kBAAkBhH,OAAQkI,IAC7CxK,KAAKsJ,kBAAkBkB,GAAGP,WAAaV,IACzCa,EAAWpK,KAAKsJ,kBAAkBkB,GAAGN,OACrClK,KAAKsJ,kBAAoBtJ,KAAKsJ,kBAAkB/G,OAAOiI,EAAG,GAC1DA,EAAIxK,KAAKsJ,kBAAkBhH,OAG1B8H,IAELpK,KAAKuK,YAAY,KAAOnB,EAAMgB,GA5FrBC,cAgGExH,UAAUqD,oBAAsBoE,EAC7C3B,QAAQ9F,UAAUqD,oBAAsBoE,EACxCtD,OAAOd,oBAAsBoE,EAE7BtC,EAAQ,SAAUoB,EAAMvI,GAEtB,GAAI2H,GAAMpF,EAAS4F,mBAWnB,OATAnI,GAAMA,MACN2H,EAAIY,KAAOA,EACXZ,EAAIF,OAASzH,EAAIyH,OAEX,KAAOc,IAAQ1J,IAAkB,eAAT0J,IAC5BZ,EAAIiC,KAAOrB,EACXZ,EAAIkC,aAAc,GAGblC,GAjHEP,YAqHGD,EAEd1B,EAAkB2B,WAElB,IAAI0C,GAAoB,SAAU7B,GAChC,IAAKA,EAAE4B,YAEL,WADA1K,MAAK4K,UAAU9B,EAAEM,KAAMN,EAFU,IAM9B9I,KAAKwJ,aANyB,CASnC,GAAIG,GAAgBb,EAAE2B,KAAOzK,KAAKwJ,YAClCpG,GAAS2G,gBAAgBJ,GAAiBb,GAnIjCuB,cAuIExH,UAAUwD,cAAgBsE,EACvChC,QAAQ9F,UAAUwD,cAAgBsE,EAClC3D,OAAOX,cAAgBsE,MAGzB,WAEE,GAAIE,GAAgB,WAAa/D,OAAMjE,SAF5B,KAMNgI,EAAe,CAClB,GAAIC,GAAehE,MAAMjE,UAAU+B,KACnCkC,OAAMjE,UAAU+B,MAAQ,WAEtB,IAAK,GADDmG,MACK1I,EAAI,EAAGpB,EAAIjB,KAAKsC,OAAYrB,EAAJoB,EAAOA,IAClCA,IAAKrC,OACP+K,EAAIf,KAAKhK,KAAKqC,GAIlB,OAAOyI,GAAa/H,MAAMgI,EAAK/H,YAG7B,WAAa8D,OAAMjE,YACvBiE,MAAMjE,UAAUmI,QAAU,SAASC,EAAQC,GACzC,IAAK,GAAI7I,GAAI,EAAGA,EAAIrC,KAAKsC,OAAQD,IAC3BA,IAAKrC,OACPiL,EAAO1K,KAAK2K,EAAMlL,KAAKqC,GAAIA,KAKE,kBAA1B8I,QAAOtI,UAAUuI,OAC1BD,OAAOtI,UAAUuI,KAAO,WACtB,MAAOpL,MAAKyC,QAAQ,aAAc,MAGjCqE,MAAMjE,UAAUwI,SACnBvE,MAAMjE,UAAUwI,OAAS,SAASC,GAChC,GAAa,SAATtL,MAA4B,OAATA,KACrB,KAAM,IAAIyH,UAGZ,IAAI8D,GAAI7H,OAAO1D,MACXwL,EAAMD,EAAEjJ,SAAW,CACvB,IAAmB,kBAARgJ,GACT,KAAM,IAAI7D,UAKZ,KAAK,GAFDgE,MACAC,EAAU1I,UAAUV,QAAU,EAAIU,UAAU,GAAK,OAC5CX,EAAI,EAAOmJ,EAAJnJ,EAASA,IACvB,GAAIA,IAAKkJ,GAAG,CACV,GAAItI,GAAMsI,EAAElJ,EAORiJ,GAAI/K,KAAKmL,EAASzI,EAAKZ,EAAGkJ,IAAME,EAAIzB,KAAK/G,GAIjD,MAAOwI,OAOb,IAAIvI,GAAiB,eACjBM,EAAiB,eACjB2C,EAAa,aACbb,EAAW,WACXqG,EAAQ,QACRC,EAAS,SACTC,EAAQ,QACRC,EAAS,SACTC,EAAQ,QACRC,EAAY,WA8CZ7I,EAA0C,mBAAhB8I,aAA8BA,YAActD,QAkOtEhD,EAAW,KACXD,EAAS,KACTwG,KACAtG,GAAkB,EAClBuG,GAAe,CAEnBzJ,GAAcG,WAEZe,kBAAkB,EAElBwI,WAAY,SAAUzJ,GAGpB,GAAI0J,GAAOjJ,EAASC,cAAc,sBAE9BiJ,EAAY,GAAIC,QAAO,GALE7I,QAQtBC,eAAe0I,EAAM,QAC1B3K,IAAK,WACH,MAAO4K,IAET3K,IAAK,SAAUsB,GACb,GAAIA,YAAesJ,QACjBD,EAAYrJ,MACP,CAGL,GAAIA,IAAQqJ,EAAUE,WAAY,MAH7B,IAMDC,IAAiBxJ,EAAM,IAAIqB,MAAM,yBAErCgI,GAAY,GAAIC,QAAOE,EAAc,IAAMA,EAAc,GAAIA,EAAc,IAG7EJ,EAAKvH,aAAa,OAAQwH,EAAUE,eA1BX9I,OA+BtBC,eAAe0I,EAAM,eAC1B3K,IAAK,WACH,GAAIgL,GAAOL,EAAKxH,aAAa,eAC7B,OAAI6H,IAAQ1L,EAAM0L,IACPA,EAEJ,MAET/K,IAAK,SAAUsB,GACTjC,EAAMiC,GACRoJ,EAAKvH,aAAa,eAAgB7B,GAElCoJ,EAAKM,gBAAgB,kBAK3B,KAAK,GAAIpL,KAAQoB,GACXA,EAAQY,eAAehC,KACzB8K,EAAK9K,GAAQoB,EAAQpB,GAlDI,IAsDzB+C,OACJ,EAAA7C,cAAsB4K,EAAMN,GAC1BrK,IAAK,WACH,MAAO4C,IAET3C,IAAK,SAAUsB,GACbqB,EAAQrB,YAAe6D,OAAQ7D,OAInC,IAAI2J,KA4BJ,QA3BA,EAAAnL,cAAsB4K,EAAML,GAC1BtK,IAAK,WACH,MAAOkL,IAETjL,IAAK,SAAUsB,GACb2J,EAAW3J,YAAe6D,OAAQ7D,QAItCoJ,EAAKN,MACLM,EAAKL,OAKH,SACA,WACA,UACA,WACA,YACA,gBACAhB,QAAQ,SAAS6B,GACjBR,EAAKQ,GAAc,WACjB7M,KAAK8M,cAAcD,GAAY9J,MAAM/C,KAAK8M,cAAe9J,cAItDqJ,GAGTU,IAAK,SAAUpK,GAIb,MADA3C,MAAKgN,YAAYhN,KAAKoM,WAAWzJ,IAC1B3C,MAGTiN,OAAQ,SAAUC,GAGhB,GAAItD,GAAUsD,CAKd,OAJ8B,gBAAnBA,KACTtD,EAAU5J,KAAKmN,cAAcD,IAG3BtD,GAAWA,EAAQkD,eACrBlD,EAAQkD,cAAcM,YAAYxD,GAC3BA,GAFT,QAMF/D,SAAU,WAER,MAAIsG,IACFvG,GAAkB,EACX5F,OAET4F,GAAkB,EAClBlG,EAAK2G,cAAc,GAAI2B,GAAM1C,IACtBtF,OAGTqN,OAAQ,SAAUxL,GAEhB,MAAO7B,MAAKsN,UAAU,KAAM,KAAMzL,GAAKgE,YAGzCpD,QAAS,SAAUZ,GAEjB,MAAO7B,MAAKwE,aAAa,KAAM,KAAM3C,GAAKgE,YAG5C0H,SAAU,WACRvN,KAAKqN,OAAOtK,MAAM/C,KAAMgD,YAG1ByC,gBAAiB,WAOf,QAAS+H,GAAOxL,EAAK0D,GAGnB,MAFAoB,OAAMjE,UAAU+B,MAAMrE,KAAKP,KAAKyN,UAAYzN,KAAK0N,YAC9C1C,QAAQ2C,EAAoB7H,KAAK9F,KAAMgC,EAAK0D,IACxC1D,EA0CT,QAAS2L,GAAoB3L,EAAK0D,EAAQkI,GA6BxC,QAASC,GAAmBpD,EAAMtC,GAEhCA,EAASA,MACTA,EAAOG,OAASH,EAAOG,WACvBH,EAAOG,OAAOyD,GAASzH,MACvB6D,EAAOG,OAAO0D,GAAaY,MAC3BzE,EAAOE,YAAa,CAapB,IAAIH,GAAQ,GAAIxI,GAAKuI,YAAYwC,EAAMtC,EACvC,OAAOD,GAhDT,GAAK0F,EAAYvB,KAAjB,CAEA,GAEIS,GAFAgB,EAAS9L,EACT+L,EAAYrI,CAGuB,iBAA5BkI,GAAYI,cACrBF,EAAS,GACThB,EAAgBc,EAAYd,cAExBA,EAAcf,GAAOzJ,OAASsL,EAAYI,cAC5CF,EAAShB,EAAcf,GAAO6B,EAAYI,cAAgB,IAE5DD,EAAY,GACRjB,EAAcd,GAAW1J,OAASsL,EAAYI,cAChDD,EAAYjB,EAAcd,GAAW4B,EAAYI,cAAgB,KAGrEJ,EAAY7B,GAAS+B,EAAO/B,GAAO6B,EAAYvB,MACtB,gBAAd0B,GACTH,EAAY5B,GAAa+B,EAAUhC,GAAO6B,EAAYvB,MAEtDuB,EAAY5B,KAEd,IAAI1H,GAAQsJ,EAAY7B,GACpBa,EAAWgB,EAAY5B,GACvByB,EAAW3G,MAAMjE,UAAU+B,MAAMrE,KAAKqN,EAAYH,SA3BD,IAqDhC,IAAjBnJ,EAAMhC,OAAc,CACtB,GAAwB,IAApBsK,EAAStK,QAAgBsL,EAAYK,YAAcvI,EAErD,MAaF,OAXAkI,GAAY5L,IAAM,KAClB4L,EAAYjB,gBAAgB,OAE5Bc,EAASzC,QAAQ2C,EAAoB7H,KAAK9F,KAAMgC,EAAK0D,IAR/BkI,EAWVvH,cAAc,GAAIwH,GAAmBjC,GAC/CtD,QAASc,KAAMuC,UAGjBiC,GAAYvH,cAAc,GAAIwH,GAAmBlC,IApEE3L,KAyEhDiF,WAAW8G,GAAO/B,MACrBJ,QAASgE,EACTM,QACE,GAAIL,GAAmB9B,KAI3B,IAAIoC,GAAWP,EAAYK,YAAcvI,CAKzC,IAJAkI,EAAYK,UAAYjO,KAAKgC,IAC7B4L,EAAY5L,IAAMsC,EAAM,GACxBsJ,EAAY9I,aAAa,MAAOR,EAAM,IAEd,IAApBsI,EAAStK,QAAgB6L,EAa3B,MAXAnO,MAAKiF,WAAW4G,GAAO7B,MACrBJ,QAASgE,EACTM,QACE,GAAIL,GAAmBjC,GACrBtD,QAASc,KAAMyC,KAEjB,GAAIgC,GAAmBhC,UAI3B4B,GAASzC,QAAQ2C,EAAoB7H,KAAK9F,KAAMgC,EAAK0D,GAKnDpB,GAAM,KAAOsI,EAAS,IAExB5M,KAAKiF,WAAW6G,GAAQ9B,MACtBJ,QAASgE,EACTM,QACE,GAAIL,GAAmBjC,GACrBtD,QAASc,KAAM0C,KAEjB,GAAI+B,GAAmB/B,MAK7B2B,EAASzC,QAAQ2C,EAAoB7H,KAAK9F,KAAMgC,EAAK0D,KAlKvD,GAAK1F,KAAKuE,cAQV2H,EAAYlC,KAAKwD,EAAO1H,KAAK9F,KAAMA,KAAKgC,QAIpCkK,EAAY5J,OAAS,IAjBE,CAqB3B,IArB2B,GAoBvB8L,GAAO1I,EACJwG,EAAY5J,OAAS,GAC1B8L,EAAOlC,EAAY,GAAG3L,KAAK,KAAM6N,GACjClC,EAAYmC,OAvBalC,IA2BZ,CA3BY,IA8BvBlH,GAAajF,KAAKiF,YAIrB6G,EAAQD,EAAOE,GAAOf,QAAQ,SAAS5B,GAEtC,KAAOnE,EAAWmE,GAAM9G,OAAS,GAAG,KAClC,GAAI4L,GAASjJ,EAAWmE,GAAM,GAAG8E,OAC7BtE,EAAU3E,EAAWmE,GAAM,GAAGQ,QAG3BsE,EAAO5L,OAAS,GACrBsH,EAAQvD,cAAc6H,EAAO,IAC7BA,EAAOG,OAETpJ,GAAWmE,GAAMiF,WA7CMlC,GAkDZ,IAyKnB,KAAK,GAAIxF,KAAUjH,GAAKsE,QACc,kBAAzBtE,GAAKsE,QAAQ2C,IACtBD,EAA+CnG,KAAKmC,EAAcG,UAAW8D,EAIjFjE,GAAcG,UAAUW,GAAkB9D,EAAKsE,WAAatE,EAAKsE,QAAQsJ,UACpE5K,EAAcG,UAAUW,KAC3Bd,EAAcG,UAAUK,IAAkB,EAG5C,IAAIoL,GAAY,IAEX5L,GAAcG,UAAUyK,YAC3B5K,EAAcG,UAAUyK,UAAY,SAASrJ,EAAOQ,EAAOzC,GACzD,GAAIuJ,GAAInI,EAASqB,OAAS,EA4B1B,OA3BAzC,GAAMA,GAAO,GACK,OAAdsM,IACFlL,EAASqB,MAAQ6J,GAEnBtO,KAAKiG,yBAGDrE,EAAWI,KAEbtC,EAAKyE,SAASC,KAAOpC,GAIR,MAAXA,EAAI,KACNA,EAAMA,EAAI4C,MAAM,IAGd7C,EAAWC,KACbA,EAAMtC,EAAKyE,SAASE,KAAKO,MAAM,EAAGlF,EAAKyE,SAASE,KAAKkK,YAAY,KAAO,GAAKvM,EAC7EA,EAAMC,EAAoBD,IAG5BtC,EAAKyE,SAASE,KAAOrC,EAErBoB,EAASqB,MAAQ8G,EACjB+C,EAAY7J,EAELzE,OAIN0C,EAAcG,UAAU2B,eAC3B9B,EAAcG,UAAU2B,aAAe,SAASP,EAAOQ,EAAOzC,GAC5D,GAAIuJ,GAAInI,EAASqB,OAAS,EADuC,IAEjEzC,EAAMA,GAAO,GACK,OAAdsM,IACFlL,EAASqB,MAAQ6J,GAEnBtO,KAAKiG,yBAGDrE,EAAWI,GACb,KAAM,IAAIwM,OAAM,uBAOlB,IAJe,MAAXxM,EAAI,KACNA,EAAMA,EAAI4C,MAAM,IAGd7C,EAAWC,GAAM,CACnB,GAAIyM,GAAc/O,EAAKyE,SAASE,KAAKkK,YAAY,KAAO,CACxDvM,GAAMtC,EAAKyE,SAASE,KAAKO,MAAM,EAAG6J,GAAezM,EACjDA,EAAMC,EAAoBD,GAU5B,MA9BiEA,GAwB3D,IAAMA,EAEZtC,EAAKyE,SAAS1B,QAAQT,GACtBoB,EAASqB,MAAQ8G,EACjB+C,EAAY7J,EAELzE,OAKXH,EAAOD,QAAU8C,IFkEanC,KAAKX,EAAU,WAAa,MAAOI,WAI3D,SAASH,EAAQD,EAASM,GGhlChCL,EAAAD,SAAkBmB,UAAAb,EAAA,GAAAY,YAAA,IHslCZ,SAASjB,EAAQD,EAASM,GItlChC,GAAAwO,GAAAxO,EAAA,EACAL,GAAAD,QAAA,SAAA+O,EAAAC,EAAAC,GACA,MAAAH,GAAAI,QAAAH,EAAAC,EAAAC,KJ6lCM,SAAShP,EAAQD,GK/lCvB,GAAAmP,GAAArL,MACA7D,GAAAD,SACAoP,OAAAD,EAAAC,OACAC,SAAAF,EAAAG,eACAC,UAAgBC,qBAChBC,QAAAN,EAAAO,yBACAR,QAAAC,EAAApL,eACA4L,SAAAR,EAAAS,iBACAC,QAAAV,EAAAW,KACAC,SAAAZ,EAAAa,oBACAC,WAAAd,EAAAe,sBACAC,QAAA/E","file":"push-state-tree.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PushStateTree\"] = factory();\n\telse\n\t\troot[\"PushStateTree\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*!\n * PushStateTree - v0.15.0 - 2016-03-31\n *  https://github.com/gartz/pushStateTree/\n *  Copyright (c) 2016 Gabriel Reitz Giannattasio <gabriel@gartz.com.br>; Licensed MIT\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PushStateTree\"] = factory();\n\telse\n\t\troot[\"PushStateTree\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tvar _defineProperty = __webpack_require__(1);\n\t\n\tvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar root = typeof window !== 'undefined' && window || global;\n\tvar document = root.document;\n\tvar location = root.location;\n\t\n\tvar isIE = function () {\n\t  var trident = window.navigator.userAgent.indexOf('Trident');\n\t  return trident >= 0;\n\t}();\n\t\n\t// Shim, to work with older browsers\n\t(function () {\n\t  // Opera and IE doesn't implement location.origin\n\t  if (!root.location.origin) {\n\t    root.location.origin = root.location.protocol + '//' + root.location.host;\n\t  }\n\t})();\n\t\n\t(function () {\n\t  /* global HTMLDocument */\n\t  if (Function.prototype.bind) {\n\t    return;\n\t  }\n\t\n\t  Function.prototype.bind = function (oThis) {\n\t    if (typeof this !== 'function') {\n\t      // closest thing possible to the ECMAScript 5 internal IsCallable function\n\t      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n\t    }\n\t\n\t    var aArgs = Array.prototype.slice.call(arguments, 1),\n\t        fToBind = this,\n\t        FNOP = function FNOP() {},\n\t        fBound = function fBound() {\n\t      var context = oThis;\n\t      if (this instanceof FNOP && oThis) {\n\t        context = this;\n\t      }\n\t      return fToBind.apply(context, aArgs.concat(Array.prototype.slice.call(arguments)));\n\t    };\n\t\n\t    FNOP.prototype = this.prototype;\n\t    fBound.prototype = new FNOP();\n\t\n\t    return fBound;\n\t  };\n\t})();\n\t\n\t// IE9 shims\n\tvar HashChangeEvent = root.HashChangeEvent;\n\tvar Event = root.Event;\n\t\n\t(function () {\n\t  if (!Element.prototype.addEventListener) {\n\t    return;\n\t  }\n\t\n\t  function CustomEvent(event, params) {\n\t    params = params || {\n\t      bubbles: false,\n\t      cancelable: false,\n\t      detail: undefined\n\t    };\n\t    var evt = document.createEvent('CustomEvent');\n\t    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n\t    return evt;\n\t  }\n\t\n\t  CustomEvent.prototype = Event.prototype;\n\t\n\t  if (!root.CustomEvent || !!isIE) {\n\t    root.CustomEvent = CustomEvent;\n\t  }\n\t\n\t  // Opera before 15 has HashChangeEvent but throw a DOM Implement error\n\t  if (!HashChangeEvent || root.opera && root.opera.version() < 15 || !!isIE) {\n\t    HashChangeEvent = root.CustomEvent;\n\t  }\n\t\n\t  if (isIE) {\n\t    Event = CustomEvent;\n\t  }\n\t\n\t  // fix for Safari\n\t  try {\n\t    new HashChangeEvent('hashchange');\n\t  } catch (e) {\n\t    HashChangeEvent = CustomEvent;\n\t  }\n\t\n\t  try {\n\t    new Event('popstate');\n\t  } catch (e) {\n\t    Event = CustomEvent;\n\t  }\n\t})();\n\t\n\t// IE 8 shims\n\t(function () {\n\t  if (Element.prototype.addEventListener || !_defineProperty2.default) {\n\t    return;\n\t  }\n\t\n\t  // create an MS event object and get prototype\n\t  var proto = document.createEventObject().constructor.prototype;\n\t\n\t  Object.defineProperty(proto, 'target', {\n\t    get: function get() {\n\t      return this.srcElement;\n\t    }\n\t  });\n\t\n\t  // IE8 addEventLister shim\n\t  var addEventListenerFunc = function addEventListenerFunc(type, handler) {\n\t    if (!this.__bindedFunctions) {\n\t      this.__bindedFunctions = [];\n\t    }\n\t\n\t    var fn = handler;\n\t\n\t    if (!('on' + type in this) || type === 'hashchange') {\n\t      this.__elemetIEid = this.__elemetIEid || '__ie__' + Math.random();\n\t      var customEventId = type + this.__elemetIEid;\n\t      //TODO: Bug???\n\t      //document.documentElement[customEventId];\n\t      var element = this;\n\t\n\t      var propHandler = function propHandler(event) {\n\t        // if the property changed is the custom jqmReady property\n\t        if (event.propertyName === customEventId) {\n\t          fn.call(element, document.documentElement[customEventId]);\n\t        }\n\t      };\n\t\n\t      this.__bindedFunctions.push({\n\t        original: fn,\n\t        binded: propHandler\n\t      });\n\t\n\t      document.documentElement.attachEvent('onpropertychange', propHandler);\n\t\n\t      if (type !== 'hashchange') {\n\t        return;\n\t      }\n\t    }\n\t\n\t    var bindedFn = fn.bind(this);\n\t\n\t    this.__bindedFunctions.push({\n\t      original: fn,\n\t      binded: bindedFn\n\t    });\n\t\n\t    this.attachEvent('on' + type, bindedFn);\n\t  };\n\t\n\t  // setup the DOM and window objects\n\t  HTMLDocument.prototype.addEventListener = addEventListenerFunc;\n\t  Element.prototype.addEventListener = addEventListenerFunc;\n\t  window.addEventListener = addEventListenerFunc;\n\t\n\t  // IE8 removeEventLister shim\n\t  var removeEventListenerFunc = function removeEventListenerFunc(type, handler) {\n\t    if (!this.__bindedFunctions) {\n\t      this.__bindedFunctions = [];\n\t    }\n\t\n\t    var fn = handler;\n\t\n\t    var bindedFn;\n\t\n\t    if (!('on' + type in this) || type === 'hashchange') {\n\t      for (var i = 0; i < this.__bindedFunctions.length; i++) {\n\t        if (this.__bindedFunctions[i].original === fn) {\n\t          bindedFn = this.__bindedFunctions[i].binded;\n\t          this.__bindedFunctions = this.__bindedFunctions.splice(i, 1);\n\t          i = this.__bindedFunctions.length;\n\t        }\n\t      }\n\t\n\t      if (bindedFn) {\n\t        document.documentElement.detachEvent('onpropertychange', bindedFn);\n\t      }\n\t\n\t      if (type !== 'hashchange') {\n\t        return;\n\t      }\n\t    }\n\t\n\t    for (var j = 0; j < this.__bindedFunctions.length; j++) {\n\t      if (this.__bindedFunctions[j].original === fn) {\n\t        bindedFn = this.__bindedFunctions[j].binded;\n\t        this.__bindedFunctions = this.__bindedFunctions.splice(j, 1);\n\t        j = this.__bindedFunctions.length;\n\t      }\n\t    }\n\t    if (!bindedFn) {\n\t      return;\n\t    }\n\t\n\t    this.detachEvent('on' + type, bindedFn);\n\t  };\n\t\n\t  // setup the DOM and window objects\n\t  HTMLDocument.prototype.removeEventListener = removeEventListenerFunc;\n\t  Element.prototype.removeEventListener = removeEventListenerFunc;\n\t  window.removeEventListener = removeEventListenerFunc;\n\t\n\t  Event = function Event(type, obj) {\n\t\n\t    var evt = document.createEventObject();\n\t\n\t    obj = obj || {};\n\t    evt.type = type;\n\t    evt.detail = obj.detail;\n\t\n\t    if (!('on' + type in root) || type === 'hashchange') {\n\t      evt.name = type;\n\t      evt.customEvent = true;\n\t    }\n\t\n\t    return evt;\n\t  };\n\t\n\t  /*jshint -W020 */\n\t  CustomEvent = Event;\n\t\n\t  HashChangeEvent = CustomEvent;\n\t\n\t  var dispatchEventFunc = function dispatchEventFunc(e) {\n\t    if (!e.customEvent) {\n\t      this.fireEvent(e.type, e);\n\t      return;\n\t    }\n\t    // no event registred\n\t    if (!this.__elemetIEid) {\n\t      return;\n\t    }\n\t    var customEventId = e.name + this.__elemetIEid;\n\t    document.documentElement[customEventId] = e;\n\t  };\n\t\n\t  // setup the Element dispatchEvent used to trigger events on the board\n\t  HTMLDocument.prototype.dispatchEvent = dispatchEventFunc;\n\t  Element.prototype.dispatchEvent = dispatchEventFunc;\n\t  window.dispatchEvent = dispatchEventFunc;\n\t})();\n\t\n\t(function () {\n\t  // modern browser support forEach, probably will be IE8\n\t  var modernBrowser = 'forEach' in Array.prototype;\n\t\n\t  // IE8 pollyfills:\n\t  // IE8 slice doesn't work with NodeList\n\t  if (!modernBrowser) {\n\t    var builtinSlice = Array.prototype.slice;\n\t    Array.prototype.slice = function () {\n\t      var arr = [];\n\t      for (var i = 0, n = this.length; i < n; i++) {\n\t        if (i in this) {\n\t          arr.push(this[i]);\n\t        }\n\t      }\n\t\n\t      return builtinSlice.apply(arr, arguments);\n\t    };\n\t  }\n\t  if (!('forEach' in Array.prototype)) {\n\t    Array.prototype.forEach = function (action, that) {\n\t      for (var i = 0; i < this.length; i++) {\n\t        if (i in this) {\n\t          action.call(that, this[i], i);\n\t        }\n\t      }\n\t    };\n\t  }\n\t  if (typeof String.prototype.trim !== 'function') {\n\t    String.prototype.trim = function () {\n\t      return this.replace(/^\\s+|\\s+$/g, '');\n\t    };\n\t  }\n\t  if (!Array.prototype.filter) {\n\t    Array.prototype.filter = function (fun /*, thisArg */) {\n\t      if (this === void 0 || this === null) {\n\t        throw new TypeError();\n\t      }\n\t\n\t      var t = Object(this);\n\t      var len = t.length >>> 0;\n\t      if (typeof fun !== 'function') {\n\t        throw new TypeError();\n\t      }\n\t\n\t      var res = [];\n\t      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n\t      for (var i = 0; i < len; i++) {\n\t        if (i in t) {\n\t          var val = t[i];\n\t\n\t          // NOTE: Technically this should Object.defineProperty at\n\t          //       the next index, as push can be affected by\n\t          //       properties on Object.prototype and Array.prototype.\n\t          //       But that method's new, and collisions should be\n\t          //       rare, so use the more-compatible alternative.\n\t          if (fun.call(thisArg, val, i, t)) {\n\t            res.push(val);\n\t          }\n\t        }\n\t      }\n\t\n\t      return res;\n\t    };\n\t  }\n\t})();\n\t\n\t// Constants for uglifiers\n\t\n\tvar USE_PUSH_STATE = 'usePushState';\n\tvar HAS_PUSH_STATE = 'hasPushState';\n\tvar HASHCHANGE = 'hashchange';\n\tvar POPSTATE = 'popstate';\n\tvar LEAVE = 'leave';\n\tvar UPDATE = 'update';\n\tvar ENTER = 'enter';\n\tvar CHANGE = 'change';\n\tvar MATCH = 'match';\n\tvar OLD_MATCH = 'oldMatch';\n\t\n\t// Helpers\n\tfunction isInt(n) {\n\t  return !isNaN(parseFloat(n)) && n % 1 === 0 && isFinite(n);\n\t}\n\t\n\tfunction wrapProperty(scope, prop, target) {\n\t  (0, _defineProperty2.default)(scope, prop, {\n\t    get: function get() {\n\t      return target;\n\t    },\n\t    set: function set() {}\n\t  });\n\t}\n\t\n\tfunction isExternal(url) {\n\t  // Check if a URL is external\n\t  return (/^[a-z0-9]+:\\/\\//i.test(url)\n\t  );\n\t}\n\t\n\tfunction isRelative(uri) {\n\t  // Check if a URI is relative path, when begin with # or / isn't relative uri\n\t  return (/^[^#/]/.test(uri)\n\t  );\n\t}\n\t\n\tfunction resolveRelativePath(path) {\n\t  // Resolve relative paths manually for browsers using hash navigation\n\t\n\t  var parts = path.split('/');\n\t  var i = 1;\n\t  while (i < parts.length) {\n\t    // if current part is `..` and previous part is different, remove both of them\n\t    if (parts[i] === '..' && i > 0 && parts[i - 1] !== '..') {\n\t      parts.splice(i - 1, 2);\n\t      i -= 2;\n\t    }\n\t    i++;\n\t  }\n\t  return parts.join('/').replace(/\\/\\.\\/|\\.\\/|\\.\\.\\//g, '/').replace(/^\\/$/, '');\n\t}\n\t\n\t// Add compatibility with old IE browsers\n\tvar elementPrototype = typeof HTMLElement !== 'undefined' ? HTMLElement : Element;\n\t\n\tfunction PushStateTree(options) {\n\t  options = options || {};\n\t  options[USE_PUSH_STATE] = options[USE_PUSH_STATE] !== false;\n\t\n\t  // Force the instance to always return a HTMLElement\n\t  if (!(this instanceof elementPrototype)) {\n\t    return PushStateTree.apply(document.createElement('pushstatetree-route'), arguments);\n\t  }\n\t\n\t  var rootElement = this;\n\t  this.VERSION = (\"0.15.0\");\n\t\n\t  // Setup options\n\t  for (var prop in options) {\n\t    if (options.hasOwnProperty(prop)) {\n\t      rootElement[prop] = options[prop];\n\t    }\n\t  }\n\t\n\t  // Allow switch between pushState or hash navigation modes, in browser that doesn't support\n\t  // pushState it will always be false. and use hash navigation enforced.\n\t  // use backend non permanent redirect when old browsers are detected in the request.\n\t  if (!PushStateTree.prototype[HAS_PUSH_STATE]) {\n\t    wrapProperty(rootElement, USE_PUSH_STATE, false);\n\t  } else {\n\t    var usePushState = options[USE_PUSH_STATE];\n\t    (0, _defineProperty2.default)(rootElement, USE_PUSH_STATE, {\n\t      get: function get() {\n\t        return usePushState;\n\t      },\n\t      set: function set(val) {\n\t        usePushState = val !== false;\n\t      }\n\t    });\n\t  }\n\t\n\t  // When enabled beautifyLocation will auto switch between hash to pushState when enabled\n\t  Object.defineProperty(rootElement, 'beautifyLocation', {\n\t    get: function get() {\n\t      return PushStateTree.prototype.beautifyLocation && usePushState;\n\t    },\n\t    set: function set(value) {\n\t      PushStateTree.prototype.beautifyLocation = value === true;\n\t    }\n\t  });\n\t  rootElement.beautifyLocation = options.beautifyLocation && rootElement.usePushState;\n\t\n\t  var basePath;\n\t  Object.defineProperty(rootElement, 'basePath', {\n\t    get: function get() {\n\t      return basePath;\n\t    },\n\t    set: function set(value) {\n\t      basePath = value || '';\n\t      if (basePath[0] !== '/') {\n\t        basePath = '/' + basePath;\n\t      }\n\t    }\n\t  });\n\t  rootElement.basePath = options.basePath;\n\t\n\t  function wrappMethodsAndPropertiesToPrototype(prop) {\n\t    if (typeof PushStateTree.prototype[prop] === 'function') {\n\t      // function wrapper\n\t      rootElement[prop] = function () {\n\t        return PushStateTree.prototype[prop].apply(this, arguments);\n\t      };\n\t    } else {\n\t      if (typeof rootElement[prop] !== 'undefined') return;\n\t      // property wrapper\n\t      (0, _defineProperty2.default)(rootElement, prop, {\n\t        get: function get() {\n\t          return PushStateTree.prototype[prop];\n\t        },\n\t        set: function set(val) {\n\t          PushStateTree.prototype[prop] = val;\n\t        }\n\t      });\n\t    }\n\t  }\n\t\n\t  //TODO: emcapsulate this\n\t  for (var protoProperty in PushStateTree.prototype) {\n\t    if (PushStateTree.prototype.hasOwnProperty(protoProperty)) {\n\t      wrappMethodsAndPropertiesToPrototype(protoProperty);\n\t    }\n\t  }\n\t\n\t  wrapProperty(rootElement, 'length', root.history.length);\n\t  wrapProperty(rootElement, 'state', root.history.state);\n\t\n\t  var cachedUri = {\n\t    url: '',\n\t    uri: ''\n\t  };\n\t  Object.defineProperty(rootElement, 'uri', {\n\t    get: function get() {\n\t      if (cachedUri.url === root.location.href) return cachedUri.uri;\n\t\n\t      var uri;\n\t      if (root.location.hash.length || root.location.href[location.href.length - 1] === '#') {\n\t        // Remove all begin # chars from the location when using hash\n\t        uri = root.location.hash.match(/^(#*)?(.*\\/?)/)[2];\n\t\n\t        var usePushState = rootElement[USE_PUSH_STATE];\n\t        if (rootElement.beautifyLocation && rootElement.isPathValid && usePushState) {\n\t          // when using pushState, replace the browser location to avoid ugly URLs\n\t\n\t          rootElement.replaceState(rootElement.state, rootElement.title, uri[0] === '/' ? uri : '/' + uri);\n\t        }\n\t      } else {\n\t        uri = root.location.pathname + root.location.search;\n\t        if (this.isPathValid) {\n\t          uri = uri.slice(this.basePath.length);\n\t        }\n\t      }\n\t\n\t      // Remove the very first slash, do don't match it as URI\n\t      uri = uri.replace(/^[\\/]+/, '');\n\t\n\t      if (rootElement.getAttribute('uri') !== uri) {\n\t        rootElement.setAttribute('uri', uri);\n\t      }\n\t\n\t      cachedUri.url = root.location.href;\n\t      cachedUri.uri = uri;\n\t      return uri;\n\t    },\n\t    configurable: true\n\t  });\n\t\n\t  Object.defineProperty(rootElement, 'isPathValid', {\n\t    get: function get() {\n\t      var uri = root.location.pathname + root.location.search;\n\t      return !this.basePath || uri.indexOf(this.basePath) === 0;\n\t    }\n\t  });\n\t\n\t  rootElement.eventStack = {\n\t    leave: [],\n\t    change: [],\n\t    enter: [],\n\t    match: []\n\t  };\n\t\n\t  root.addEventListener(POPSTATE, function () {\n\t    var eventURI = rootElement.uri;\n\t    var eventState = rootElement.state;\n\t    rootElement.rulesDispatcher();\n\t\n\t    oldURI = eventURI;\n\t    oldState = eventState;\n\t\n\t    // If there is holding dispatch in the event, do it now\n\t    if (holdingDispatch) {\n\t      this.dispatch();\n\t    }\n\t  }.bind(rootElement));\n\t\n\t  var readOnhashchange = false;\n\t  var onhashchange = function () {\n\t    // Workaround IE8\n\t    if (readOnhashchange) return;\n\t\n\t    // Don't dispatch, because already have dispatched in popstate event\n\t    if (oldURI === rootElement.uri) return;\n\t\n\t    var eventURI = rootElement.uri;\n\t    var eventState = rootElement.state;\n\t    rootElement.rulesDispatcher();\n\t\n\t    oldURI = eventURI;\n\t    oldState = eventState;\n\t\n\t    // If there is holding dispatch in the event, do it now\n\t    if (holdingDispatch) {\n\t      this.dispatch();\n\t    }\n\t  }.bind(rootElement);\n\t\n\t  rootElement.avoidHashchangeHandler = function () {\n\t    // Avoid triggering hashchange event\n\t    root.removeEventListener(HASHCHANGE, onhashchange);\n\t    readOnhashchange = true;\n\t  };\n\t\n\t  root.addEventListener(HASHCHANGE, onhashchange);\n\t\n\t  // Uglify propourses\n\t  var dispatchHashChange = function dispatchHashChange() {\n\t    root.dispatchEvent(new HashChangeEvent(HASHCHANGE));\n\t  };\n\t\n\t  // Modern browsers\n\t  document.addEventListener('DOMContentLoaded', dispatchHashChange);\n\t  // Some IE browsers\n\t  root.addEventListener('readystatechange', dispatchHashChange);\n\t  // Almost all browsers\n\t  root.addEventListener('load', function () {\n\t    var _this = this;\n\t\n\t    dispatchHashChange();\n\t\n\t    if (isIE) {\n\t      root.setInterval(function () {\n\t        if (_this.uri !== oldURI) {\n\t          dispatchHashChange();\n\t          return;\n\t        }\n\t        if (readOnhashchange) {\n\t          readOnhashchange = false;\n\t          oldURI = _this.uri;\n\t          root.addEventListener(HASHCHANGE, onhashchange);\n\t        }\n\t      }, 50);\n\t    }\n\t  }.bind(rootElement));\n\t\n\t  return this;\n\t}\n\t\n\t/*eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"oldState\" }]*/\n\tvar oldState = null;\n\tvar oldURI = null;\n\tvar eventsQueue = [];\n\tvar holdingDispatch = false;\n\tvar holdDispatch = false;\n\t\n\tPushStateTree.prototype = {\n\t  // Version ~0.11 beatifyLocation is enabled by default\n\t  beautifyLocation: true,\n\t\n\t  createRule: function createRule(options) {\n\t    // Create a pushstreamtree-rule element from a literal object\n\t\n\t    var rule = document.createElement('pushstatetree-rule');\n\t\n\t    var ruleRegex = new RegExp('');\n\t\n\t    // Bind rule property with element attribute\n\t    Object.defineProperty(rule, 'rule', {\n\t      get: function get() {\n\t        return ruleRegex;\n\t      },\n\t      set: function set(val) {\n\t        if (val instanceof RegExp) {\n\t          ruleRegex = val;\n\t        } else {\n\t\n\t          // IE8 trigger set from the property when update the attribute, avoid recursive loop\n\t          if (val === ruleRegex.toString()) return;\n\t\n\t          // Slice the pattern from the attribute\n\t          var slicedPattern = (val + '').match(/^\\/(.+)\\/([gmi]*)|(.*)/);\n\t\n\t          ruleRegex = new RegExp(slicedPattern[1] || slicedPattern[3], slicedPattern[2]);\n\t        }\n\t\n\t        rule.setAttribute('rule', ruleRegex.toString());\n\t      }\n\t    });\n\t\n\t    // Bind rule property with element attribute\n\t    Object.defineProperty(rule, 'parentGroup', {\n\t      get: function get() {\n\t        var attr = rule.getAttribute('parent-group');\n\t        if (attr && isInt(attr)) {\n\t          return +attr;\n\t        }\n\t        return null;\n\t      },\n\t      set: function set(val) {\n\t        if (isInt(val)) {\n\t          rule.setAttribute('parent-group', val);\n\t        } else {\n\t          rule.removeAttribute('parent-group');\n\t        }\n\t      }\n\t    });\n\t\n\t    for (var prop in options) {\n\t      if (options.hasOwnProperty(prop)) {\n\t        rule[prop] = options[prop];\n\t      }\n\t    } // Match is always a array, so you can test for match[n] anytime\n\t    var match = [];\n\t    (0, _defineProperty2.default)(rule, MATCH, {\n\t      get: function get() {\n\t        return match;\n\t      },\n\t      set: function set(val) {\n\t        match = val instanceof Array ? val : [];\n\t      }\n\t    });\n\t\n\t    var oldMatch = [];\n\t    (0, _defineProperty2.default)(rule, OLD_MATCH, {\n\t      get: function get() {\n\t        return oldMatch;\n\t      },\n\t      set: function set(val) {\n\t        oldMatch = val instanceof Array ? val : [];\n\t      }\n\t    });\n\t\n\t    rule[MATCH] = [];\n\t    rule[OLD_MATCH] = [];\n\t\n\t    // Replicate the methods from `route` to the rule, by transversing until find and execute\n\t    // the router method, not a fast operation, but ensure the right route to be triggered\n\t    ['assign', 'navigate', 'replace', 'dispatch', 'pushState', 'replaceState'].forEach(function (methodName) {\n\t      rule[methodName] = function () {\n\t        this.parentElement[methodName].apply(this.parentElement, arguments);\n\t      };\n\t    });\n\t\n\t    return rule;\n\t  },\n\t\n\t  add: function add(options) {\n\t    // Transform any literal object in a pushstatetree-rule and append it\n\t\n\t    this.appendChild(this.createRule(options));\n\t    return this;\n\t  },\n\t\n\t  remove: function remove(queryOrElement) {\n\t    // Remove a pushstateree-rule, pass a element or it query\n\t\n\t    var element = queryOrElement;\n\t    if (typeof queryOrElement === 'string') {\n\t      element = this.querySelector(queryOrElement);\n\t    }\n\t\n\t    if (element && element.parentElement) {\n\t      element.parentElement.removeChild(element);\n\t      return element;\n\t    }\n\t  },\n\t\n\t  dispatch: function dispatch() {\n\t    // Deferred trigger the actual browser location\n\t    if (holdDispatch) {\n\t      holdingDispatch = true;\n\t      return this;\n\t    }\n\t    holdingDispatch = false;\n\t    root.dispatchEvent(new Event(POPSTATE));\n\t    return this;\n\t  },\n\t\n\t  assign: function assign(url) {\n\t    // Shortcut for pushState and dispatch methods\n\t    return this.pushState(null, null, url).dispatch();\n\t  },\n\t\n\t  replace: function replace(url) {\n\t    // Shortcut for pushState and dispatch methods\n\t    return this.replaceState(null, null, url).dispatch();\n\t  },\n\t\n\t  navigate: function navigate() {\n\t    this.assign.apply(this, arguments);\n\t  },\n\t\n\t  rulesDispatcher: function rulesDispatcher() {\n\t    // Will dispatch the right events in each rule\n\t    /*jshint validthis:true */\n\t\n\t    // Abort if the basePath isn't valid for this router\n\t    if (!this.isPathValid) return;\n\t\n\t    function runner(uri, oldURI) {\n\t      Array.prototype.slice.call(this.children || this.childNodes).forEach(recursiveDispatcher.bind(this, uri, oldURI));\n\t      return uri;\n\t    }\n\t\n\t    eventsQueue.push(runner.bind(this, this.uri));\n\t\n\t    // Is there already a queue been executed, so just add the runner\n\t    // and let the main queue resolve it\n\t    if (eventsQueue.length > 1) {\n\t      return;\n\t    }\n\t\n\t    // Chain execute the evetsQueue\n\t    var last = oldURI;\n\t    while (eventsQueue.length > 0) {\n\t      last = eventsQueue[0].call(null, last);\n\t      eventsQueue.shift();\n\t    }\n\t\n\t    // If a dispatch is triggered inside a event callback, it need to hold\n\t    holdDispatch = true;\n\t\n\t    // A stack of all events to be dispatched, to ensure the priority order\n\t    var eventStack = this.eventStack;\n\t\n\t    // Order of events stack execution, leave event isn't here because it executes in the\n\t    // recursiveDispatcher, for one loop less\n\t    [CHANGE, ENTER, MATCH].forEach(function (type) {\n\t      // Execute the leave stack of events\n\t      while (eventStack[type].length > 0) {\n\t        var events = eventStack[type][0].events;\n\t        var element = eventStack[type][0].element;\n\t\n\t        //TODO: Ignore if there isn't same in the enter stack and remove it\n\t        while (events.length > 0) {\n\t          element.dispatchEvent(events[0]);\n\t          events.shift();\n\t        }\n\t        eventStack[type].shift();\n\t      }\n\t    });\n\t\n\t    // If there is holding dispatchs in the event, do it now\n\t    holdDispatch = false;\n\t\n\t    function recursiveDispatcher(uri, oldURI, ruleElement) {\n\t      if (!ruleElement.rule) return;\n\t\n\t      var useURI = uri;\n\t      var useOldURI = oldURI;\n\t      var parentElement;\n\t\n\t      if (typeof ruleElement.parentGroup === 'number') {\n\t        useURI = '';\n\t        parentElement = ruleElement.parentElement;\n\t\n\t        if (parentElement[MATCH].length > ruleElement.parentGroup) useURI = parentElement[MATCH][ruleElement.parentGroup] || '';\n\t\n\t        useOldURI = '';\n\t        if (parentElement[OLD_MATCH].length > ruleElement.parentGroup) useOldURI = parentElement[OLD_MATCH][ruleElement.parentGroup] || '';\n\t      }\n\t\n\t      ruleElement[MATCH] = useURI[MATCH](ruleElement.rule);\n\t      if (typeof useOldURI === 'string') {\n\t        ruleElement[OLD_MATCH] = useOldURI[MATCH](ruleElement.rule);\n\t      } else {\n\t        ruleElement[OLD_MATCH] = [];\n\t      }\n\t      var match = ruleElement[MATCH];\n\t      var oldMatch = ruleElement[OLD_MATCH];\n\t      var children = Array.prototype.slice.call(ruleElement.children);\n\t\n\t      function PushStateTreeEvent(name, params) {\n\t\n\t        params = params || {};\n\t        params.detail = params.detail || {};\n\t        params.detail[MATCH] = match || [];\n\t        params.detail[OLD_MATCH] = oldMatch || [];\n\t        params.cancelable = true;\n\t\n\t        if (false) {\n\t          /*eslint no-console: \"off\" */\n\t          console.log({\n\t            name: name,\n\t            ruleElement: ruleElement,\n\t            params: params,\n\t            useURI: useURI,\n\t            useOldURI: useOldURI\n\t          });\n\t          if (console.trace) console.trace();\n\t        }\n\t        var event = new root.CustomEvent(name, params);\n\t        return event;\n\t      }\n\t\n\t      // Not match or leave?\n\t      if (match.length === 0) {\n\t        if (oldMatch.length === 0 || ruleElement.routerURI !== oldURI) {\n\t          // just not match...\n\t          return;\n\t        }\n\t        ruleElement.uri = null;\n\t        ruleElement.removeAttribute('uri');\n\t\n\t        children.forEach(recursiveDispatcher.bind(this, uri, oldURI));\n\t\n\t        // Don't use stack for LEAVE event, dispatch in this loop\n\t        ruleElement.dispatchEvent(new PushStateTreeEvent(UPDATE, {\n\t          detail: { type: LEAVE }\n\t        }));\n\t\n\t        ruleElement.dispatchEvent(new PushStateTreeEvent(LEAVE));\n\t        return;\n\t      }\n\t\n\t      // dispatch the match event\n\t      this.eventStack[MATCH].push({\n\t        element: ruleElement,\n\t        events: [new PushStateTreeEvent(MATCH)]\n\t      });\n\t\n\t      var isNewURI = ruleElement.routerURI !== oldURI;\n\t      ruleElement.routerURI = this.uri;\n\t      ruleElement.uri = match[0];\n\t      ruleElement.setAttribute('uri', match[0]);\n\t\n\t      if (oldMatch.length === 0 || isNewURI) {\n\t        // stack dispatch enter event\n\t        this.eventStack[ENTER].push({\n\t          element: ruleElement,\n\t          events: [new PushStateTreeEvent(UPDATE, {\n\t            detail: { type: ENTER }\n\t          }), new PushStateTreeEvent(ENTER)]\n\t        });\n\t\n\t        children.forEach(recursiveDispatcher.bind(this, uri, oldURI));\n\t        return;\n\t      }\n\t\n\t      // if has something changed, dispatch the change event\n\t      if (match[0] !== oldMatch[0]) {\n\t        // stack dispatch enter event\n\t        this.eventStack[CHANGE].push({\n\t          element: ruleElement,\n\t          events: [new PushStateTreeEvent(UPDATE, {\n\t            detail: { type: CHANGE }\n\t          }), new PushStateTreeEvent(CHANGE)]\n\t        });\n\t      }\n\t\n\t      children.forEach(recursiveDispatcher.bind(this, uri, oldURI));\n\t    }\n\t  }\n\t};\n\t\n\tfunction preProcessUriBeforeExecuteNativeHistoryMethods(method) {\n\t  /*jshint validthis:true */\n\t  var scopeMethod = method;\n\t  this[method] = function () {\n\t    // Wrap method\n\t\n\t    // remove the method from arguments\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    // if has a basePath translate the not relative paths to use the basePath\n\t    if (scopeMethod === 'pushState' || scopeMethod === 'replaceState') {\n\t\n\t      if (!isExternal(args[2])) {\n\t        // When not external link, need to normalize the URI\n\t\n\t        if (isRelative(args[2])) {\n\t          // Relative to the uri\n\t          var basePath = this.uri.match(/^([^?#]*)\\//);\n\t          basePath = basePath ? basePath[1] + '/' : '';\n\t          args[2] = basePath + args[2];\n\t        } else {\n\t          // This isn't relative, will cleanup / and # from the begin and use the remain path\n\t          args[2] = args[2].match(/^([#/]*)?(.*)/)[2];\n\t        }\n\t\n\t        if (!this[USE_PUSH_STATE]) {\n\t\n\t          // Ignore basePath when using location.hash and resolve relative path and keep\n\t          // the current location.pathname, some browsers history API might apply the new pathname\n\t          // with the hash content if not explicit\n\t          args[2] = location.pathname + '#' + resolveRelativePath(args[2]);\n\t        } else {\n\t\n\t          // Add the basePath to your uri, not allowing to go by pushState outside the basePath\n\t          args[2] = this.basePath + args[2];\n\t        }\n\t      }\n\t    }\n\t\n\t    root.history[scopeMethod].apply(root.history, args);\n\t\n\t    // Chainnable\n\t    return this;\n\t  };\n\t}\n\t\n\t// Wrap history methods\n\tfor (var method in root.history) {\n\t  if (typeof root.history[method] === 'function') {\n\t    preProcessUriBeforeExecuteNativeHistoryMethods.call(PushStateTree.prototype, method);\n\t  }\n\t}\n\t\n\tPushStateTree.prototype[HAS_PUSH_STATE] = root.history && !!root.history.pushState;\n\tif (!PushStateTree.prototype[HAS_PUSH_STATE]) {\n\t  PushStateTree.prototype[USE_PUSH_STATE] = false;\n\t}\n\t\n\tvar lastTitle = null;\n\t\n\tif (!PushStateTree.prototype.pushState) {\n\t  PushStateTree.prototype.pushState = function (state, title, uri) {\n\t    var t = document.title || '';\n\t    uri = uri || '';\n\t    if (lastTitle !== null) {\n\t      document.title = lastTitle;\n\t    }\n\t    this.avoidHashchangeHandler();\n\t\n\t    // Replace hash url\n\t    if (isExternal(uri)) {\n\t      // this will redirect the browser, so doesn't matters the rest...\n\t      root.location.href = uri;\n\t    }\n\t\n\t    // Remove the has if is it present\n\t    if (uri[0] === '#') {\n\t      uri = uri.slice(1);\n\t    }\n\t\n\t    if (isRelative(uri)) {\n\t      uri = root.location.hash.slice(1, root.location.hash.lastIndexOf('/') + 1) + uri;\n\t      uri = resolveRelativePath(uri);\n\t    }\n\t\n\t    root.location.hash = uri;\n\t\n\t    document.title = t;\n\t    lastTitle = title;\n\t\n\t    return this;\n\t  };\n\t}\n\t\n\tif (!PushStateTree.prototype.replaceState) {\n\t  PushStateTree.prototype.replaceState = function (state, title, uri) {\n\t    var t = document.title || '';\n\t    uri = uri || '';\n\t    if (lastTitle !== null) {\n\t      document.title = lastTitle;\n\t    }\n\t    this.avoidHashchangeHandler();\n\t\n\t    // Replace the url\n\t    if (isExternal(uri)) {\n\t      throw new Error('Invalid url replace.');\n\t    }\n\t\n\t    if (uri[0] === '#') {\n\t      uri = uri.slice(1);\n\t    }\n\t\n\t    if (isRelative(uri)) {\n\t      var relativePos = root.location.hash.lastIndexOf('/') + 1;\n\t      uri = root.location.hash.slice(1, relativePos) + uri;\n\t      uri = resolveRelativePath(uri);\n\t    }\n\t\n\t    // Always use hash navigation\n\t    uri = '#' + uri;\n\t\n\t    root.location.replace(uri);\n\t    document.title = t;\n\t    lastTitle = title;\n\t\n\t    return this;\n\t  };\n\t}\n\t\n\t// Node import support\n\tmodule.exports = PushStateTree;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = { \"default\": __webpack_require__(2), __esModule: true };\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(3);\n\tmodule.exports = function defineProperty(it, key, desc){\n\t  return $.setDesc(it, key, desc);\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tvar $Object = Object;\n\tmodule.exports = {\n\t  create:     $Object.create,\n\t  getProto:   $Object.getPrototypeOf,\n\t  isEnum:     {}.propertyIsEnumerable,\n\t  getDesc:    $Object.getOwnPropertyDescriptor,\n\t  setDesc:    $Object.defineProperty,\n\t  setDescs:   $Object.defineProperties,\n\t  getKeys:    $Object.keys,\n\t  getNames:   $Object.getOwnPropertyNames,\n\t  getSymbols: $Object.getOwnPropertySymbols,\n\t  each:       [].forEach\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** push-state-tree.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 73a3621111e337ada1f6\n **/","var root = typeof window !== 'undefined' && window || global;\nvar document = root.document;\nvar location = root.location;\n\nvar isIE = (function(){\n  var trident = window.navigator.userAgent.indexOf('Trident');\n  return trident >= 0;\n}());\n\n// Shim, to work with older browsers\n(function () {\n  // Opera and IE doesn't implement location.origin\n  if (!root.location.origin) {\n    root.location.origin = root.location.protocol + '//' + root.location.host;\n  }\n})();\n\n(function () {\n  /* global HTMLDocument */\n  if (Function.prototype.bind) { return; }\n\n  Function.prototype.bind = function (oThis) {\n    if (typeof this !== 'function') {\n      // closest thing possible to the ECMAScript 5 internal IsCallable function\n      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n    }\n\n    var aArgs = Array.prototype.slice.call(arguments, 1),\n      fToBind = this,\n      FNOP = function () {},\n      fBound = function () {\n        var context = oThis;\n        if (this instanceof FNOP && oThis){\n          context = this;\n        }\n        return fToBind.apply(context, aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n    FNOP.prototype = this.prototype;\n    fBound.prototype = new FNOP();\n\n    return fBound;\n  };\n})();\n\n// IE9 shims\nvar HashChangeEvent = root.HashChangeEvent;\nvar Event = root.Event;\n\n(function () {\n  if (!Element.prototype.addEventListener) { return; }\n\n  function CustomEvent(event, params) {\n    params = params || {\n      bubbles: false,\n      cancelable: false,\n      detail: undefined\n    };\n    var evt = document.createEvent('CustomEvent');\n    evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n    return evt;\n  }\n\n  CustomEvent.prototype = Event.prototype;\n\n  if (!root.CustomEvent || !!isIE) {\n    root.CustomEvent = CustomEvent;\n  }\n\n  // Opera before 15 has HashChangeEvent but throw a DOM Implement error\n  if (!HashChangeEvent || (root.opera && root.opera.version() < 15) || !!isIE) {\n    HashChangeEvent = root.CustomEvent;\n  }\n\n  if (isIE) {\n    Event = CustomEvent;\n  }\n\n  // fix for Safari\n  try {\n    new HashChangeEvent('hashchange');\n  } catch(e) {\n    HashChangeEvent = CustomEvent;\n  }\n\n  try {\n    new Event('popstate');\n  } catch (e) {\n    Event = CustomEvent;\n  }\n})();\n\n// IE 8 shims\n(function () {\n  if (Element.prototype.addEventListener || !Object.defineProperty) { return; }\n\n  // create an MS event object and get prototype\n  var proto = document.createEventObject().constructor.prototype;\n\n  Object.defineProperty(proto, 'target', {\n    get: function() { return this.srcElement; }\n  });\n\n  // IE8 addEventLister shim\n  var addEventListenerFunc = function(type, handler) {\n    if (!this.__bindedFunctions) {\n      this.__bindedFunctions = [];\n    }\n\n    var fn = handler;\n\n    if (!('on' + type in this) || type === 'hashchange') {\n      this.__elemetIEid = this.__elemetIEid || '__ie__' + Math.random();\n      var customEventId = type + this.__elemetIEid;\n      //TODO: Bug???\n      //document.documentElement[customEventId];\n      var element = this;\n\n      var propHandler = function (event) {\n        // if the property changed is the custom jqmReady property\n        if (event.propertyName === customEventId) {\n          fn.call(element, document.documentElement[customEventId]);\n        }\n      };\n\n      this.__bindedFunctions.push({\n        original: fn,\n        binded: propHandler\n      });\n\n      document.documentElement.attachEvent('onpropertychange', propHandler);\n\n      if (type !== 'hashchange') { return; }\n    }\n\n    var bindedFn = fn.bind(this);\n\n    this.__bindedFunctions.push({\n      original: fn,\n      binded: bindedFn\n    });\n\n    this.attachEvent('on' + type, bindedFn);\n  };\n\n  // setup the DOM and window objects\n  HTMLDocument.prototype.addEventListener = addEventListenerFunc;\n  Element.prototype.addEventListener = addEventListenerFunc;\n  window.addEventListener = addEventListenerFunc;\n\n  // IE8 removeEventLister shim\n  var removeEventListenerFunc = function(type, handler) {\n    if (!this.__bindedFunctions) {\n      this.__bindedFunctions = [];\n    }\n\n    var fn = handler;\n\n    var bindedFn;\n\n    if (!('on' + type in this) || type === 'hashchange') {\n      for (var i = 0; i < this.__bindedFunctions.length; i++) {\n        if (this.__bindedFunctions[i].original === fn) {\n          bindedFn = this.__bindedFunctions[i].binded;\n          this.__bindedFunctions = this.__bindedFunctions.splice(i, 1);\n          i = this.__bindedFunctions.length;\n        }\n      }\n\n      if (bindedFn) {\n        document.documentElement.detachEvent('onpropertychange', bindedFn);\n      }\n\n      if (type !== 'hashchange') { return; }\n    }\n\n    for (var j = 0; j < this.__bindedFunctions.length; j++) {\n      if (this.__bindedFunctions[j].original === fn) {\n        bindedFn = this.__bindedFunctions[j].binded;\n        this.__bindedFunctions = this.__bindedFunctions.splice(j, 1);\n        j = this.__bindedFunctions.length;\n      }\n    }\n    if (!bindedFn) { return; }\n\n    this.detachEvent('on' + type, bindedFn);\n  };\n\n  // setup the DOM and window objects\n  HTMLDocument.prototype.removeEventListener = removeEventListenerFunc;\n  Element.prototype.removeEventListener = removeEventListenerFunc;\n  window.removeEventListener = removeEventListenerFunc;\n\n  Event = function (type, obj) {\n\n    var evt = document.createEventObject();\n\n    obj = obj || {};\n    evt.type = type;\n    evt.detail = obj.detail;\n\n    if (!('on' + type in root) || type === 'hashchange') {\n      evt.name = type;\n      evt.customEvent = true;\n    }\n\n    return evt;\n  };\n\n  /*jshint -W020 */\n  CustomEvent = Event;\n\n  HashChangeEvent = CustomEvent;\n\n  var dispatchEventFunc = function (e) {\n    if (!e.customEvent) {\n      this.fireEvent(e.type, e);\n      return;\n    }\n    // no event registred\n    if (!this.__elemetIEid) {\n      return;\n    }\n    var customEventId = e.name + this.__elemetIEid;\n    document.documentElement[customEventId] = e;\n  };\n\n  // setup the Element dispatchEvent used to trigger events on the board\n  HTMLDocument.prototype.dispatchEvent = dispatchEventFunc;\n  Element.prototype.dispatchEvent = dispatchEventFunc;\n  window.dispatchEvent = dispatchEventFunc;\n})();\n\n(function () {\n  // modern browser support forEach, probably will be IE8\n  var modernBrowser = 'forEach' in Array.prototype;\n\n  // IE8 pollyfills:\n  // IE8 slice doesn't work with NodeList\n  if (!modernBrowser) {\n    var builtinSlice = Array.prototype.slice;\n    Array.prototype.slice = function() {\n      var arr = [];\n      for (var i = 0, n = this.length; i < n; i++) {\n        if (i in this) {\n          arr.push(this[i]);\n        }\n      }\n\n      return builtinSlice.apply(arr, arguments);\n    };\n  }\n  if (!('forEach' in Array.prototype)) {\n    Array.prototype.forEach = function(action, that) {\n      for (var i = 0; i < this.length; i++) {\n        if (i in this) {\n          action.call(that, this[i], i);\n        }\n      }\n    };\n  }\n  if (typeof String.prototype.trim !== 'function') {\n    String.prototype.trim = function() {\n      return this.replace(/^\\s+|\\s+$/g, '');\n    };\n  }\n  if (!Array.prototype.filter) {\n    Array.prototype.filter = function(fun /*, thisArg */) {\n      if (this === void 0 || this === null) {\n        throw new TypeError();\n      }\n\n      var t = Object(this);\n      var len = t.length >>> 0;\n      if (typeof fun !== 'function') {\n        throw new TypeError();\n      }\n\n      var res = [];\n      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\n      for (var i = 0; i < len; i++) {\n        if (i in t) {\n          var val = t[i];\n\n          // NOTE: Technically this should Object.defineProperty at\n          //       the next index, as push can be affected by\n          //       properties on Object.prototype and Array.prototype.\n          //       But that method's new, and collisions should be\n          //       rare, so use the more-compatible alternative.\n          if (fun.call(thisArg, val, i, t)) { res.push(val); }\n        }\n      }\n\n      return res;\n    };\n  }\n})();\n\n// Constants for uglifiers\n\nvar USE_PUSH_STATE = 'usePushState';\nvar HAS_PUSH_STATE = 'hasPushState';\nvar HASHCHANGE = 'hashchange';\nvar POPSTATE = 'popstate';\nvar LEAVE = 'leave';\nvar UPDATE = 'update';\nvar ENTER = 'enter';\nvar CHANGE = 'change';\nvar MATCH = 'match';\nvar OLD_MATCH = 'oldMatch';\n\n// Helpers\nfunction isInt(n) {\n  return !isNaN(parseFloat(n)) && n % 1 === 0 && isFinite(n);\n}\n\nfunction wrapProperty(scope, prop, target) {\n  Object.defineProperty(scope, prop, {\n    get: function () {\n      return target;\n    },\n    set: function () {}\n  });\n}\n\nfunction isExternal(url) {\n  // Check if a URL is external\n  return (/^[a-z0-9]+:\\/\\//i).test(url);\n}\n\nfunction isRelative(uri) {\n  // Check if a URI is relative path, when begin with # or / isn't relative uri\n  return (/^[^#/]/).test(uri);\n}\n\nfunction resolveRelativePath(path) {\n  // Resolve relative paths manually for browsers using hash navigation\n\n  var parts = path.split('/');\n  var i = 1;\n  while (i < parts.length) {\n    // if current part is `..` and previous part is different, remove both of them\n    if (parts[i] === '..' && i > 0 && parts[i-1] !== '..') {\n      parts.splice(i - 1, 2);\n      i -= 2;\n    }\n    i++;\n  }\n  return parts\n    .join('/')\n    .replace(/\\/\\.\\/|\\.\\/|\\.\\.\\//g, '/')\n    .replace(/^\\/$/, '');\n}\n\n// Add compatibility with old IE browsers\nvar elementPrototype = typeof HTMLElement !== 'undefined' ? HTMLElement : Element;\n\nfunction PushStateTree(options) {\n  options = options || {};\n  options[USE_PUSH_STATE] = options[USE_PUSH_STATE] !== false;\n\n  // Force the instance to always return a HTMLElement\n  if (!(this instanceof elementPrototype)) {\n    return PushStateTree.apply(document.createElement('pushstatetree-route'), arguments);\n  }\n\n  var rootElement = this;\n  this.VERSION = VERSION;\n\n  // Setup options\n  for (var prop in options) {\n    if (options.hasOwnProperty(prop)) {\n      rootElement[prop] = options[prop];\n    }\n  }\n\n  // Allow switch between pushState or hash navigation modes, in browser that doesn't support\n  // pushState it will always be false. and use hash navigation enforced.\n  // use backend non permanent redirect when old browsers are detected in the request.\n  if (!PushStateTree.prototype[HAS_PUSH_STATE]) {\n    wrapProperty(rootElement, USE_PUSH_STATE, false);\n  } else {\n    var usePushState = options[USE_PUSH_STATE];\n    Object.defineProperty(rootElement, USE_PUSH_STATE, {\n      get: function () {\n        return usePushState;\n      },\n      set: function (val) {\n        usePushState = val !== false;\n      }\n    });\n  }\n\n  // When enabled beautifyLocation will auto switch between hash to pushState when enabled\n  Object.defineProperty(rootElement, 'beautifyLocation', {\n    get: function () {\n      return PushStateTree.prototype.beautifyLocation && usePushState;\n    },\n    set: function (value) {\n      PushStateTree.prototype.beautifyLocation = value === true;\n    }\n  });\n  rootElement.beautifyLocation = options.beautifyLocation && rootElement.usePushState;\n\n  var basePath;\n  Object.defineProperty(rootElement, 'basePath', {\n    get: function () {\n      return basePath;\n    },\n    set: function (value) {\n      basePath = value || '';\n      if (basePath[0] !== '/') {\n        basePath = '/' + basePath;\n      }\n    }\n  });\n  rootElement.basePath = options.basePath;\n\n  function wrappMethodsAndPropertiesToPrototype(prop) {\n    if (typeof PushStateTree.prototype[prop] === 'function') {\n      // function wrapper\n      rootElement[prop] = function () {\n        return PushStateTree.prototype[prop].apply(this, arguments);\n      };\n    } else {\n      if (typeof rootElement[prop] !== 'undefined') return;\n      // property wrapper\n      Object.defineProperty(rootElement, prop, {\n        get: function () {\n          return PushStateTree.prototype[prop];\n        },\n        set: function (val) {\n          PushStateTree.prototype[prop] = val;\n        }\n      });\n    }\n  }\n\n  //TODO: emcapsulate this\n  for (var protoProperty in PushStateTree.prototype) {\n    if (PushStateTree.prototype.hasOwnProperty(protoProperty)) {\n      wrappMethodsAndPropertiesToPrototype(protoProperty);\n    }\n  }\n\n  wrapProperty(rootElement, 'length', root.history.length);\n  wrapProperty(rootElement, 'state', root.history.state);\n\n  var cachedUri = {\n    url: '',\n    uri: ''\n  };\n  Object.defineProperty(rootElement, 'uri', {\n    get: function () {\n      if (cachedUri.url === root.location.href) return cachedUri.uri;\n\n      var uri;\n      if (root.location.hash.length || root.location.href[location.href.length - 1] === '#') {\n        // Remove all begin # chars from the location when using hash\n        uri = root.location.hash.match(/^(#*)?(.*\\/?)/)[2];\n\n        var usePushState = rootElement[USE_PUSH_STATE];\n        if (rootElement.beautifyLocation && rootElement.isPathValid && usePushState) {\n          // when using pushState, replace the browser location to avoid ugly URLs\n\n          rootElement.replaceState(\n            rootElement.state,\n            rootElement.title,\n            uri[0] === '/' ? uri : '/' + uri\n          );\n        }\n      } else {\n        uri = root.location.pathname + root.location.search;\n        if (this.isPathValid) {\n          uri = uri.slice(this.basePath.length);\n        }\n      }\n\n      // Remove the very first slash, do don't match it as URI\n      uri = uri.replace(/^[\\/]+/, '');\n\n      if (rootElement.getAttribute('uri') !== uri) {\n        rootElement.setAttribute('uri', uri);\n      }\n\n      cachedUri.url = root.location.href;\n      cachedUri.uri = uri;\n      return uri;\n    },\n    configurable: true\n  });\n\n  Object.defineProperty(rootElement, 'isPathValid', {\n    get: function () {\n      var uri = root.location.pathname + root.location.search;\n      return !this.basePath || (uri).indexOf(this.basePath) === 0;\n    }\n  });\n\n  rootElement.eventStack = {\n    leave: [],\n    change: [],\n    enter: [],\n    match: []\n  };\n\n  root.addEventListener(POPSTATE, function () {\n    var eventURI = rootElement.uri;\n    var eventState = rootElement.state;\n    rootElement.rulesDispatcher();\n\n    oldURI = eventURI;\n    oldState = eventState;\n\n    // If there is holding dispatch in the event, do it now\n    if (holdingDispatch) {\n      this.dispatch();\n    }\n  }.bind(rootElement));\n\n  var readOnhashchange = false;\n  var onhashchange = function () {\n    // Workaround IE8\n    if (readOnhashchange) return;\n\n    // Don't dispatch, because already have dispatched in popstate event\n    if (oldURI === rootElement.uri) return;\n\n    var eventURI = rootElement.uri;\n    var eventState = rootElement.state;\n    rootElement.rulesDispatcher();\n\n    oldURI = eventURI;\n    oldState = eventState;\n\n    // If there is holding dispatch in the event, do it now\n    if (holdingDispatch) {\n      this.dispatch();\n    }\n  }.bind(rootElement);\n\n  rootElement.avoidHashchangeHandler = function () {\n    // Avoid triggering hashchange event\n    root.removeEventListener(HASHCHANGE, onhashchange);\n    readOnhashchange = true;\n  };\n\n  root.addEventListener(HASHCHANGE, onhashchange);\n\n  // Uglify propourses\n  var dispatchHashChange = function () {\n    root.dispatchEvent(new HashChangeEvent(HASHCHANGE));\n  };\n\n  // Modern browsers\n  document.addEventListener('DOMContentLoaded', dispatchHashChange);\n  // Some IE browsers\n  root.addEventListener('readystatechange', dispatchHashChange);\n  // Almost all browsers\n  root.addEventListener('load', function () {\n    dispatchHashChange();\n\n    if (isIE) {\n      root.setInterval(() => {\n        if (this.uri !== oldURI) {\n          dispatchHashChange();\n          return;\n        }\n        if (readOnhashchange) {\n          readOnhashchange = false;\n          oldURI = this.uri;\n          root.addEventListener(HASHCHANGE, onhashchange);\n        }\n      }, 50);\n    }\n  }.bind(rootElement));\n\n  return this;\n}\n\n/*eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"oldState\" }]*/\nvar oldState = null;\nvar oldURI = null;\nvar eventsQueue = [];\nvar holdingDispatch = false;\nvar holdDispatch = false;\n\nPushStateTree.prototype = {\n  // Version ~0.11 beatifyLocation is enabled by default\n  beautifyLocation: true,\n\n  createRule: function (options) {\n    // Create a pushstreamtree-rule element from a literal object\n\n    var rule = document.createElement('pushstatetree-rule');\n\n    var ruleRegex = new RegExp('');\n\n    // Bind rule property with element attribute\n    Object.defineProperty(rule, 'rule', {\n      get: function () {\n        return ruleRegex;\n      },\n      set: function (val) {\n        if (val instanceof RegExp){\n          ruleRegex = val;\n        } else {\n\n          // IE8 trigger set from the property when update the attribute, avoid recursive loop\n          if (val === ruleRegex.toString()) return;\n\n          // Slice the pattern from the attribute\n          var slicedPattern = (val + '').match(/^\\/(.+)\\/([gmi]*)|(.*)/);\n\n          ruleRegex = new RegExp(slicedPattern[1] || slicedPattern[3], slicedPattern[2]);\n        }\n\n        rule.setAttribute('rule', ruleRegex.toString());\n      }\n    });\n\n    // Bind rule property with element attribute\n    Object.defineProperty(rule, 'parentGroup', {\n      get: function () {\n        var attr = rule.getAttribute('parent-group');\n        if (attr && isInt(attr)) {\n          return + attr;\n        }\n        return null;\n      },\n      set: function (val) {\n        if (isInt(val)) {\n          rule.setAttribute('parent-group', val);\n        } else {\n          rule.removeAttribute('parent-group');\n        }\n      }\n    });\n\n    for (var prop in options)\n      if (options.hasOwnProperty(prop)) {\n        rule[prop] = options[prop];\n      }\n\n    // Match is always a array, so you can test for match[n] anytime\n    var match = [];\n    Object.defineProperty(rule, MATCH, {\n      get: function () {\n        return match;\n      },\n      set: function (val) {\n        match = val instanceof Array ? val : [];\n      }\n    });\n\n    var oldMatch = [];\n    Object.defineProperty(rule, OLD_MATCH, {\n      get: function () {\n        return oldMatch;\n      },\n      set: function (val) {\n        oldMatch = val instanceof Array ? val : [];\n      }\n    });\n\n    rule[MATCH] = [];\n    rule[OLD_MATCH] = [];\n\n    // Replicate the methods from `route` to the rule, by transversing until find and execute\n    // the router method, not a fast operation, but ensure the right route to be triggered\n    [\n      'assign',\n      'navigate',\n      'replace',\n      'dispatch',\n      'pushState',\n      'replaceState'\n    ].forEach(function(methodName){\n      rule[methodName] = function(){\n        this.parentElement[methodName].apply(this.parentElement, arguments);\n      };\n    });\n\n    return rule;\n  },\n\n  add: function (options) {\n    // Transform any literal object in a pushstatetree-rule and append it\n\n    this.appendChild(this.createRule(options));\n    return this;\n  },\n\n  remove: function (queryOrElement) {\n    // Remove a pushstateree-rule, pass a element or it query\n\n    var element = queryOrElement;\n    if (typeof queryOrElement === 'string') {\n      element = this.querySelector(queryOrElement);\n    }\n\n    if (element && element.parentElement) {\n      element.parentElement.removeChild(element);\n      return element;\n    }\n  },\n\n  dispatch: function () {\n    // Deferred trigger the actual browser location\n    if (holdDispatch) {\n      holdingDispatch = true;\n      return this;\n    }\n    holdingDispatch = false;\n    root.dispatchEvent(new Event(POPSTATE));\n    return this;\n  },\n\n  assign: function (url) {\n    // Shortcut for pushState and dispatch methods\n    return this.pushState(null, null, url).dispatch();\n  },\n\n  replace: function (url) {\n    // Shortcut for pushState and dispatch methods\n    return this.replaceState(null, null, url).dispatch();\n  },\n\n  navigate: function(){\n    this.assign.apply(this, arguments);\n  },\n\n  rulesDispatcher: function () {\n    // Will dispatch the right events in each rule\n    /*jshint validthis:true */\n\n    // Abort if the basePath isn't valid for this router\n    if (!this.isPathValid) return;\n\n    function runner(uri, oldURI) {\n      Array.prototype.slice.call(this.children || this.childNodes)\n        .forEach(recursiveDispatcher.bind(this, uri, oldURI));\n      return uri;\n    }\n\n    eventsQueue.push(runner.bind(this, this.uri));\n\n    // Is there already a queue been executed, so just add the runner\n    // and let the main queue resolve it\n    if (eventsQueue.length > 1) { return; }\n\n    // Chain execute the evetsQueue\n    var last = oldURI;\n    while (eventsQueue.length > 0) {\n      last = eventsQueue[0].call(null, last);\n      eventsQueue.shift();\n    }\n\n    // If a dispatch is triggered inside a event callback, it need to hold\n    holdDispatch = true;\n\n    // A stack of all events to be dispatched, to ensure the priority order\n    var eventStack = this.eventStack;\n\n    // Order of events stack execution, leave event isn't here because it executes in the\n    // recursiveDispatcher, for one loop less\n    [CHANGE, ENTER, MATCH].forEach(function(type){\n      // Execute the leave stack of events\n      while (eventStack[type].length > 0) {\n        var events = eventStack[type][0].events;\n        var element = eventStack[type][0].element;\n\n        //TODO: Ignore if there isn't same in the enter stack and remove it\n        while (events.length > 0){\n          element.dispatchEvent(events[0]);\n          events.shift();\n        }\n        eventStack[type].shift();\n      }\n    });\n\n    // If there is holding dispatchs in the event, do it now\n    holdDispatch = false;\n\n    function recursiveDispatcher(uri, oldURI, ruleElement) {\n      if (!ruleElement.rule) return;\n\n      var useURI = uri;\n      var useOldURI = oldURI;\n      var parentElement;\n\n      if (typeof ruleElement.parentGroup === 'number') {\n        useURI = '';\n        parentElement = ruleElement.parentElement;\n\n        if (parentElement[MATCH].length > ruleElement.parentGroup)\n          useURI = parentElement[MATCH][ruleElement.parentGroup] || '';\n\n        useOldURI = '';\n        if (parentElement[OLD_MATCH].length > ruleElement.parentGroup)\n          useOldURI = parentElement[OLD_MATCH][ruleElement.parentGroup] || '';\n      }\n\n      ruleElement[MATCH] = useURI[MATCH](ruleElement.rule);\n      if (typeof useOldURI === 'string') {\n        ruleElement[OLD_MATCH] = useOldURI[MATCH](ruleElement.rule);\n      } else {\n        ruleElement[OLD_MATCH] = [];\n      }\n      var match = ruleElement[MATCH];\n      var oldMatch = ruleElement[OLD_MATCH];\n      var children = Array.prototype.slice.call(ruleElement.children);\n\n      function PushStateTreeEvent(name, params) {\n\n        params = params || {};\n        params.detail = params.detail || {};\n        params.detail[MATCH] = match || [];\n        params.detail[OLD_MATCH] = oldMatch || [];\n        params.cancelable = true;\n\n        if (DEBUG) {\n          /*eslint no-console: \"off\" */\n          console.log({\n            name: name,\n            ruleElement: ruleElement,\n            params: params,\n            useURI: useURI,\n            useOldURI: useOldURI\n          });\n          if (console.trace) console.trace();\n        }\n        var event = new root.CustomEvent(name, params);\n        return event;\n      }\n\n      // Not match or leave?\n      if (match.length === 0) {\n        if (oldMatch.length === 0 || ruleElement.routerURI !== oldURI) {\n          // just not match...\n          return;\n        }\n        ruleElement.uri = null;\n        ruleElement.removeAttribute('uri');\n\n        children.forEach(recursiveDispatcher.bind(this, uri, oldURI));\n\n        // Don't use stack for LEAVE event, dispatch in this loop\n        ruleElement.dispatchEvent(new PushStateTreeEvent(UPDATE, {\n          detail: {type: LEAVE}\n        }));\n\n        ruleElement.dispatchEvent(new PushStateTreeEvent(LEAVE));\n        return;\n      }\n\n      // dispatch the match event\n      this.eventStack[MATCH].push({\n        element: ruleElement,\n        events: [\n          new PushStateTreeEvent(MATCH)\n        ]\n      });\n\n      var isNewURI = ruleElement.routerURI !== oldURI;\n      ruleElement.routerURI = this.uri;\n      ruleElement.uri = match[0];\n      ruleElement.setAttribute('uri', match[0]);\n\n      if (oldMatch.length === 0 || isNewURI) {\n        // stack dispatch enter event\n        this.eventStack[ENTER].push({\n          element: ruleElement,\n          events: [\n            new PushStateTreeEvent(UPDATE, {\n              detail: {type: ENTER}\n            }),\n            new PushStateTreeEvent(ENTER)\n          ]\n        });\n\n        children.forEach(recursiveDispatcher.bind(this, uri, oldURI));\n        return;\n      }\n\n      // if has something changed, dispatch the change event\n      if (match[0] !== oldMatch[0]) {\n        // stack dispatch enter event\n        this.eventStack[CHANGE].push({\n          element: ruleElement,\n          events: [\n            new PushStateTreeEvent(UPDATE, {\n              detail: {type: CHANGE}\n            }),\n            new PushStateTreeEvent(CHANGE)\n          ]\n        });\n      }\n\n      children.forEach(recursiveDispatcher.bind(this, uri, oldURI));\n    }\n  }\n};\n\nfunction preProcessUriBeforeExecuteNativeHistoryMethods(method) {\n  /*jshint validthis:true */\n  var scopeMethod = method;\n  this[method] = function () {\n    // Wrap method\n\n    // remove the method from arguments\n    var args = Array.prototype.slice.call(arguments);\n\n    // if has a basePath translate the not relative paths to use the basePath\n    if (scopeMethod === 'pushState' || scopeMethod === 'replaceState') {\n\n      if (!isExternal(args[2])) {\n        // When not external link, need to normalize the URI\n\n        if (isRelative(args[2])) {\n          // Relative to the uri\n          var basePath = this.uri.match(/^([^?#]*)\\//);\n          basePath = basePath ? basePath[1] + '/' : '';\n          args[2] = basePath + args[2];\n        } else {\n          // This isn't relative, will cleanup / and # from the begin and use the remain path\n          args[2] = args[2].match(/^([#/]*)?(.*)/)[2];\n        }\n\n        if (!this[USE_PUSH_STATE]) {\n\n          // Ignore basePath when using location.hash and resolve relative path and keep\n          // the current location.pathname, some browsers history API might apply the new pathname\n          // with the hash content if not explicit\n          args[2] = location.pathname + '#' + resolveRelativePath(args[2]);\n        } else {\n\n          // Add the basePath to your uri, not allowing to go by pushState outside the basePath\n          args[2] = this.basePath + args[2];\n        }\n      }\n    }\n\n    root.history[scopeMethod].apply(root.history, args);\n\n    // Chainnable\n    return this;\n  };\n}\n\n// Wrap history methods\nfor (var method in root.history) {\n  if (typeof root.history[method] === 'function') {\n    preProcessUriBeforeExecuteNativeHistoryMethods.call(PushStateTree.prototype, method);\n  }\n}\n\nPushStateTree.prototype[HAS_PUSH_STATE] = root.history && !!root.history.pushState;\nif (!PushStateTree.prototype[HAS_PUSH_STATE]) {\n  PushStateTree.prototype[USE_PUSH_STATE] = false;\n}\n\nvar lastTitle = null;\n\nif (!PushStateTree.prototype.pushState) {\n  PushStateTree.prototype.pushState = function(state, title, uri) {\n    var t = document.title || '';\n    uri = uri || '';\n    if (lastTitle !== null) {\n      document.title = lastTitle;\n    }\n    this.avoidHashchangeHandler();\n\n    // Replace hash url\n    if (isExternal(uri)) {\n      // this will redirect the browser, so doesn't matters the rest...\n      root.location.href = uri;\n    }\n\n    // Remove the has if is it present\n    if (uri[0] === '#') {\n      uri = uri.slice(1);\n    }\n\n    if (isRelative(uri)) {\n      uri = root.location.hash.slice(1, root.location.hash.lastIndexOf('/') + 1) + uri;\n      uri = resolveRelativePath(uri);\n    }\n\n    root.location.hash = uri;\n\n    document.title = t;\n    lastTitle = title;\n\n    return this;\n  };\n}\n\nif (!PushStateTree.prototype.replaceState) {\n  PushStateTree.prototype.replaceState = function(state, title, uri) {\n    var t = document.title || '';\n    uri = uri || '';\n    if (lastTitle !== null) {\n      document.title = lastTitle;\n    }\n    this.avoidHashchangeHandler();\n\n    // Replace the url\n    if (isExternal(uri)) {\n      throw new Error('Invalid url replace.');\n    }\n\n    if (uri[0] === '#') {\n      uri = uri.slice(1);\n    }\n\n    if (isRelative(uri)) {\n      var relativePos = root.location.hash.lastIndexOf('/') + 1;\n      uri = root.location.hash.slice(1, relativePos) + uri;\n      uri = resolveRelativePath(uri);\n    }\n\n    // Always use hash navigation\n    uri = '#' + uri;\n\n    root.location.replace(uri);\n    document.title = t;\n    lastTitle = title;\n\n    return this;\n  };\n}\n\n// Node import support\nmodule.exports = PushStateTree;\n\n\n/** WEBPACK FOOTER **\n ** ./src/pushStateTree.js\n **/","module.exports = { \"default\": require(\"core-js/library/fn/object/define-property\"), __esModule: true };\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/core-js/object/define-property.js\n ** module id = 1\n ** module chunks = 0 1\n **/","var $ = require('../../modules/$');\nmodule.exports = function defineProperty(it, key, desc){\n  return $.setDesc(it, key, desc);\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/fn/object/define-property.js\n ** module id = 2\n ** module chunks = 0 1\n **/","var $Object = Object;\nmodule.exports = {\n  create:     $Object.create,\n  getProto:   $Object.getPrototypeOf,\n  isEnum:     {}.propertyIsEnumerable,\n  getDesc:    $Object.getOwnPropertyDescriptor,\n  setDesc:    $Object.defineProperty,\n  setDescs:   $Object.defineProperties,\n  getKeys:    $Object.keys,\n  getNames:   $Object.getOwnPropertyNames,\n  getSymbols: $Object.getOwnPropertySymbols,\n  each:       [].forEach\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/core-js/library/modules/$.js\n ** module id = 3\n ** module chunks = 0 1\n **/"],"sourceRoot":""}